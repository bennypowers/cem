/*
Copyright Â© 2025 Benny Powers <web@bennypowers.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package export

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

var _ FrameworkExporter = (*AngularExporter)(nil)

// AngularExporter generates Angular standalone component wrappers.
type AngularExporter struct{}

func (a *AngularExporter) Name() string { return "angular" }

func (a *AngularExporter) ExportElement(element ExportElement, cfg FrameworkExportConfig) (map[string]string, error) {
	componentName := TagNameToComponentName(element.TagName, cfg.StripPrefix)

	tmpl, err := getAngularTemplate()
	if err != nil {
		return nil, fmt.Errorf("parsing angular template: %w", err)
	}

	data := struct {
		ExportElement
		ComponentName string
	}{
		ExportElement: element,
		ComponentName: componentName,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("executing angular template for %s: %w", element.TagName, err)
	}

	filename := componentName + ".component.ts"
	return map[string]string{filename: buf.String()}, nil
}

func (a *AngularExporter) ExportIndex(elements []ExportElement, cfg FrameworkExportConfig) (map[string]string, error) {
	files := make(map[string]string)

	// Barrel export
	var b strings.Builder
	b.WriteString("// Generated by cem export - do not edit\n")
	for _, elem := range elements {
		name := TagNameToComponentName(elem.TagName, cfg.StripPrefix)
		fmt.Fprintf(&b, "export { %sComponent } from './%s.component';\n", name, name)
	}
	files["index.ts"] = b.String()

	// NgModule
	moduleName := cfg.ModuleName
	if moduleName == "" {
		moduleName = "ComponentsModule"
	}

	type componentEntry struct {
		ComponentName string
	}
	var components []componentEntry
	for _, elem := range elements {
		components = append(components, componentEntry{
			ComponentName: TagNameToComponentName(elem.TagName, cfg.StripPrefix),
		})
	}

	tmpl, err := template.New("angular-module.ts.tmpl").ParseFS(templateFS, "templates/angular-module.ts.tmpl")
	if err != nil {
		return nil, fmt.Errorf("parsing angular module template: %w", err)
	}

	data := struct {
		ModuleName string
		Components []componentEntry
	}{
		ModuleName: moduleName,
		Components: components,
	}

	var moduleBuf bytes.Buffer
	if err := tmpl.Execute(&moduleBuf, data); err != nil {
		return nil, fmt.Errorf("executing angular module template: %w", err)
	}

	files[moduleName+".module.ts"] = moduleBuf.String()

	return files, nil
}
