[{"body":"For go binaries:\ngo install bennypowers.dev/cem@latest For NPM projects:\nnpm install --save-dev @pwrs/cem Or clone this repository and build from source:\ngit clone https://github.com/bennypowers/cem.git cd cem make Shell Completion cem supports shell completion for Bash, Zsh, Fish, and PowerShell. The completion scripts provide tab completion for commands, flags, and file paths.\nBash To load completions in your current shell session:\nsource \u0026lt;(cem completion bash) To load completions for every new session, execute once:\nLinux:\ncem completion bash \u0026gt; /etc/bash_completion.d/cem macOS:\ncem completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/cem Zsh To load completions in your current shell session:\nsource \u0026lt;(cem completion zsh) To load completions for every new session, execute once:\ncem completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cem\u0026#34; You will need to start a new shell for this setup to take effect.\nFish To load completions in your current shell session:\ncem completion fish | source To load completions for every new session, execute once:\ncem completion fish \u0026gt; ~/.config/fish/completions/cem.fish PowerShell To load completions in your current shell session:\ncem completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your PowerShell profile.\n","link":"https://bennypowers.dev/cem/docs/installation/","section":"docs","title":"Installation"},{"body":"You can configure cem via a cem.yaml file in your project\u0026rsquo;s .config directory, or by using command-line flags.\nConfiguration File Here is a complete example of a .config/cem.yaml file with all available options explained.\n# The canonical public source control URL for your repository root. # Used for generating source links in the manifest. sourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; # Configuration for the `generate` command. generate: # A list of glob patterns for files to include in the analysis. files: - \u0026#34;src/**/*.ts\u0026#34; # A list of glob patterns for files to exclude from the analysis. exclude: - \u0026#34;src/**/*.test.ts\u0026#34; # The path to write the final custom-elements.json manifest. # If omitted, the manifest is written to standard output. output: \u0026#34;custom-elements.json\u0026#34; # By default, certain files like TypeScript declaration files (`.d.ts`) are excluded. # Set to `true` to include all files matched by the `files` glob. noDefaultExcludes: false # Configuration for integrating Design Tokens. designTokens: # An npm specifier or local path to a DTCG-formatted JSON module. spec: \u0026#34;npm:@my-ds/tokens/tokens.json\u0026#34; # A CSS custom property prefix to apply to the design tokens. prefix: \u0026#34;--my-ds\u0026#34; # Configuration for discovering element demos. demoDiscovery: # A glob pattern to find demo files. fileGlob: \u0026#34;src/**/demos/*.html\u0026#34; # URLPattern for extracting parameters from demo file paths. # Uses standard URLPattern syntax with named parameters. urlPattern: \u0026#34;/src/:component/demos/:demo.html\u0026#34; # Go template to construct the canonical URL for a demo. # Uses {{.param}} syntax with optional template functions. # Available functions: alias, slug, lower, upper urlTemplate: \u0026#34;https://example.com/components/{{.component | alias}}/demo/{{.demo | slug}}/\u0026#34; # Configuration for validation warnings. warnings: disable: # Disable entire categories - \u0026#34;lifecycle\u0026#34; - \u0026#34;private\u0026#34; # Or disable specific warning rules - \u0026#34;lifecycle-lit-render\u0026#34; - \u0026#34;implementation-static-styles\u0026#34; Demo Discovery Features The demo discovery system supports multiple ways to control how demos are associated with elements and how their URLs are generated.\nHTML5 Microdata Demos can use HTML5 microdata to explicitly declare their URLs and associations:\n\u0026lt;!-- Explicit URL declaration --\u0026gt; \u0026lt;meta itemprop=\u0026#34;demo-url\u0026#34; content=\u0026#34;/elements/call-to-action/demo/\u0026#34;\u0026gt; \u0026lt;meta itemprop=\u0026#34;description\u0026#34; content=\u0026#34;Primary variant demonstration\u0026#34;\u0026gt; \u0026lt;!-- Rich markdown description --\u0026gt; \u0026lt;script type=\u0026#34;text/markdown\u0026#34; itemprop=\u0026#34;description\u0026#34;\u0026gt; # Call to Action Demo Showcases primary variant with styling, accessibility, and interaction states. \u0026lt;/script\u0026gt; \u0026lt;!-- Explicit element association --\u0026gt; \u0026lt;meta itemprop=\u0026#34;demo-for\u0026#34; content=\u0026#34;rh-button pf-button\u0026#34;\u0026gt; Association Priority The system uses the following priority order to associate demos with elements:\nExplicit microdata: \u0026lt;meta itemprop=\u0026quot;demo-for\u0026quot; content=\u0026quot;element-name\u0026quot;\u0026gt; Path-based: Elements whose aliases appear in demo file paths Content-based: Custom elements found in the demo HTML Path-Based Association with URLPattern When a urlPattern is configured, path-based association becomes parameter-position aware. Element aliases only match when they appear in path positions that correspond to URLPattern parameters.\nExample Configuration:\ndemoDiscovery: fileGlob: \u0026#34;shop/**/demos/*.html\u0026#34; urlPattern: \u0026#34;/shop/:element/:demo.html\u0026#34; urlTemplate: \u0026#34;https://mysite.com/shop/{{.element | alias}}/{{.demo}}/\u0026#34; Element Aliases:\naliases: my-shop-button: \u0026#34;shop-button\u0026#34; my-accordion: \u0026#34;accordion\u0026#34; my-accordion-header: \u0026#34;accordion-header\u0026#34; Path Matching Behavior:\n✅ /shop/shop-button/basic.html → matches my-shop-button (alias \u0026ldquo;shop-button\u0026rdquo; in :element position) ❌ /shop/my-shop-button/basic.html → no match (alias \u0026ldquo;shop-button\u0026rdquo; ≠ \u0026ldquo;my-shop-button\u0026rdquo;) ✅ /shop/accordion-header/demo.html → matches my-accordion-header only ❌ /shop/accordion-header/demo.html → does NOT match my-accordion (prevents false positives) This precision matching prevents issues where shorter aliases (like \u0026ldquo;accordion\u0026rdquo;) incorrectly match longer path segments (like \u0026ldquo;my-accordion-header\u0026rdquo;).\nLegacy Behavior (no URLPattern): When urlPattern is not configured, the system falls back to compatibility mode with improved substring matching that prioritizes longer, more specific aliases over shorter ones.\nDescription Sources Demo descriptions are extracted exclusively from microdata:\nMeta tags: \u0026lt;meta itemprop=\u0026quot;description\u0026quot; content=\u0026quot;Simple description\u0026quot;\u0026gt; Script tags: \u0026lt;script type=\u0026quot;text/markdown\u0026quot; itemprop=\u0026quot;description\u0026quot;\u0026gt;Rich **markdown** content\u0026lt;/script\u0026gt; URL Generation Priority URLs are generated using the following priority:\nExplicit microdata: \u0026lt;meta itemprop=\u0026quot;demo-url\u0026quot; content=\u0026quot;/path/to/demo/\u0026quot;\u0026gt; URLPattern fallback: Using urlPattern and urlTemplate configuration No URL: Demo is skipped if no pattern matches URL Template Functions The urlTemplate uses Go template syntax with a set of built-in functions for transforming URLPattern parameters:\nFunction Description Example alias Apply element alias mapping from configuration {{.tag | alias}} slug Convert to URL-friendly slug format {{.demo | slug}} lower Convert to lowercase {{.component | lower}} upper Convert to uppercase {{.section | upper}} Template Examples:\n# Basic parameter interpolation urlTemplate: \u0026#34;https://example.com/{{.component}}/{{.demo}}/\u0026#34; # Apply alias transformation urlTemplate: \u0026#34;https://example.com/{{.component | alias}}/{{.demo}}/\u0026#34; # Chain multiple functions urlTemplate: \u0026#34;https://example.com/{{.component | alias | slug}}/{{.demo | lower}}/\u0026#34; # Function call syntax (alternative) urlTemplate: \u0026#34;https://example.com/{{alias .component}}/{{slug .demo}}/\u0026#34; Important: All transformations must be explicitly specified. Unlike previous versions, no automatic aliasing or slugification is applied unless explicitly requested in the template.\nConfiguration Examples Minimal (microdata-driven):\ndemoDiscovery: fileGlob: elements/**/demo/*.html URLPattern with explicit configuration:\ndemoDiscovery: fileGlob: elements/**/demo/*.html urlPattern: \u0026#34;/elements/:element/demo/:demo.html\u0026#34; urlTemplate: \u0026#34;https://site.com/components/{{.element | alias}}/demo/{{.demo | slug}}/\u0026#34; Complex multi-site example:\ndemoDiscovery: fileGlob: src/components/**/demos/*.html urlPattern: \u0026#34;/src/components/:component/demos/:variant.html\u0026#34; urlTemplate: \u0026#34;https://{{.component | alias | lower}}.examples.com/{{.variant | slug}}/\u0026#34; Global Flags These flags can be used with any cem command.\nFlag Description --config Path to a custom config file. --package deno-style package specifier, or path to the local package directory. --verbose, -v Enable verbose logging output. --help, -h Show help for a command. Command-Line Flags All configuration options can also be set via command-line flags. Flags will always override any values set in the configuration file.\nFor example, to override the output and exclude options for the generate command:\ncem generate --output my-manifest.json --exclude \u0026#34;src/legacy/**\u0026#34; Validate Command Flags The validate command supports additional flags:\nFlag Description --disable Disable specific warning rules or categories (repeatable). --format Output format: text (default) or json. For example, to validate with disabled warnings and JSON output:\ncem validate --disable lifecycle --disable private --format json ","link":"https://bennypowers.dev/cem/docs/configuration/","section":"docs","title":"Configuration"},{"body":"The CEM Language Server provides intelligent IDE features for custom elements in HTML and TypeScript files. It analyzes your custom elements manifest files to offer contextual autocomplete, hover documentation, and other editor enhancements. CEM discovers all the custom elements manifests available to your project (in your package.json), and watches for changes to your element sources to keep an in-memory version of your local element manifest up to date.\nFeatures Autocomplete Get up-to-date HTML element API completions in HTML files and Lit template literals.\nTag name completion for custom elements Attribute name completion based on element schemas Attribute value completion for known value sets i.e. TypeScript unions Slot attribute value completion for direct children of elements with slots Event, DOM property, and Boolean attribute support in lit templates. Hover Documentation Get element API documentation close to where you use them with Hover docs.\nElement descriptions, properties, and usage examples Attribute documentation with type information Links to source code and external documentation Go-to-Definition Quickly jump to your element, attribute, event, etc. definitions.\nJump to custom element source definitions Support for tag names and attributes (extensible for slots and events) Go-to-References Find all usages of custom elements across your entire workspace.\nPlace cursor on element: Position cursor anywhere within a custom element tag name Workspace-wide search: Finds all references across HTML, TypeScript, and JavaScript files Gitignore filtering: Respects your project\u0026rsquo;s .gitignore file to exclude irrelevant files like node_modules/ Clean results: Shows only start tags to avoid duplicate entries for opening and closing tags Template literal support: Works within TypeScript html template literals and similar constructs Workspace Symbol Search Search and navigate custom elements across your entire workspace.\nGlobal element search: Use your IDE\u0026rsquo;s symbol search (Ctrl+T in VS Code) to find custom elements Fuzzy matching: Quickly locate elements with partial names and case-insensitive search Direct navigation: Click search results to jump immediately to element source files Workspace-wide coverage: Searches all custom elements from your manifests and dependencies Error Detection \u0026amp; Autofixes Real-time validation with intelligent error correction.\nSlot validation: Detects invalid slot attribute values with smart suggestions Tag name validation: Validates custom element tag names with two intelligent error classes: Typo detection: Suggests corrections for misspelled tag names (e.g., \u0026ldquo;my-buttom\u0026rdquo; → \u0026ldquo;my-button\u0026rdquo;) Missing imports: Detects elements that exist but aren\u0026rsquo;t imported, with package-aware import suggestions Attribute validation: Validates HTML attributes using authoritative MDN browser-compat-data: Global attributes: Validates against official HTML global attributes (class, id, data-, aria-, event handlers) Custom element attributes: Validates against custom element manifest schemas with typo suggestions Standards-based: Uses MDN browser-compat-data, automatically updated in CI/CD Attribute value validation: Validates attribute values against their manifest type definitions: Union types: Validates against available options with typo suggestions (e.g., \u0026quot;red\u0026quot; | \u0026quot;green\u0026quot; | \u0026quot;blue\u0026quot;) Literal types: Exact string matching with case correction (e.g., \u0026quot;primary\u0026quot;) Number types: Numeric format validation for number attributes Boolean types: Validates HTML boolean attribute semantics (presence = true, absence = false) Array types: Informational guidance about format diversity (JSON, comma-separated, space-separated) One-click autofixes: Automatically correct typos and add missing imports using your editor\u0026rsquo;s quick fix feature Smart import suggestions: Resolves proper package names from package.json for npm packages vs. local modules Intelligent error messaging: Helpful guidance instead of overwhelming lists for large projects Quick Start Install using Go:\ngo install bennypowers.dev/cem@latest Or, using NPM:\nnpm install --global @pwrs/cem@latest The language server communicates via the Language Server Protocol (LSP) over standard input/output. Most modern editors support LSP through extensions or built-in features.\nIDE Setup Neovim For Neovim 0.12+\u0026rsquo;s native LSP configuration support, create ~/.config/nvim/lsp/cem.lua:\n---https://bennypowers.dev/cem/ --- ---`cem lsp` provides editor features for custom-elements a.k.a. web components --- ---Install with go ---```sh ---go install bennypowers.dev/cem ---``` ---Or with NPM ---```sh ---npm install -g @pwrs/cem ---``` --- ---@type vim.lsp.ClientConfig return { cmd = { \u0026#39;cem\u0026#39;, \u0026#39;lsp\u0026#39; }, root_markers = { \u0026#39;custom-elements.json\u0026#39;, \u0026#39;package.json\u0026#39;, \u0026#39;.git\u0026#39; }, filetypes = { \u0026#39;html\u0026#39;, \u0026#39;typescript\u0026#39;, \u0026#39;javascript\u0026#39; }, -- Control debug logging via LSP trace levels trace = \u0026#39;off\u0026#39;, -- \u0026#39;off\u0026#39; | \u0026#39;messages\u0026#39; | \u0026#39;verbose\u0026#39; } VS Code Install the Custom Elements Language Server extension from the VS Code marketplace. The extension bundles the language server and provides configuration options.\nConfiguration options in settings.json:\n{ \u0026#34;cem.lsp.executable\u0026#34;: \u0026#34;\u0026#34;, // Custom path (empty = use bundled) \u0026#34;cem.lsp.trace.server\u0026#34;: \u0026#34;off\u0026#34; // LSP trace level: \u0026#34;off\u0026#34; | \u0026#34;messages\u0026#34; | \u0026#34;verbose\u0026#34; } Emacs Depending on which LSP plugin you use, configure emacs to run cem for HTML, javascript, and typescript files:\nFor lsp-mode:\n(lsp-register-client (make-lsp-client :new-connection (lsp-stdio-connection \u0026#39;(\u0026#34;cem\u0026#34; \u0026#34;lsp\u0026#34;)) :major-modes \u0026#39;(html-mode typescript-mode js-mode) :server-id \u0026#39;cem-lsp)) For eglot:\n(add-to-list \u0026#39;eglot-server-programs \u0026#39;((html-mode typescript-mode js-mode) . (\u0026#34;cem\u0026#34; \u0026#34;lsp\u0026#34;))) Other Editors Configure your LSP client to run cem lsp for file types html, typescript, and javascript. The server communicates over stdio and follows the standard LSP specification.\nConfiguration Debug Logging Debug logging is controlled via the LSP standard $/setTrace notification. Most editors expose this through trace level settings:\n\u0026quot;off\u0026quot; - No debug logging (default) \u0026quot;messages\u0026quot; - Basic debug logging \u0026quot;verbose\u0026quot; - Detailed debug logging Supported LSP Methods Text Document Features\ntextDocument/hover - Show element and attribute documentation on hover textDocument/completion - Provide tag and attribute completion suggestions textDocument/definition - Jump to custom element source definitions textDocument/publishDiagnostics - Report validation errors with intelligent suggestions textDocument/codeAction - Provide one-click autofixes for validation errors textDocument/didOpen - Track when documents are opened in the editor textDocument/didChange - Handle incremental document changes textDocument/didClose - Clean up resources when documents are closed Workspace Features\nworkspace/symbol - Search and navigate custom elements across the entire workspace Server Lifecycle\ninitialize - Establish server capabilities and workspace configuration shutdown - Gracefully terminate the language server $/setTrace - Control debug logging verbosity (LSP standard) Example: Slot Validation The language server provides real-time validation for slot attributes with intelligent autofixes:\n\u0026lt;!-- ❌ Invalid slot name --\u0026gt; \u0026lt;my-card\u0026gt; \u0026lt;div slot=\u0026#34;heade\u0026#34;\u0026gt;Title\u0026lt;/div\u0026gt; \u0026lt;!-- Red squiggles appear --\u0026gt; \u0026lt;/my-card\u0026gt; \u0026lt;!-- ✅ After autofix (Ctrl+. → \u0026#34;Change \u0026#39;heade\u0026#39; to \u0026#39;header\u0026#39;\u0026#34;) --\u0026gt; \u0026lt;my-card\u0026gt; \u0026lt;div slot=\u0026#34;header\u0026#34;\u0026gt;Title\u0026lt;/div\u0026gt; \u0026lt;!-- Automatically corrected --\u0026gt; \u0026lt;/my-card\u0026gt; When you type an invalid slot name, the language server:\nDetects the error and shows red squiggles Suggests corrections based on available slots from your manifest Provides one-click fixes through your editor\u0026rsquo;s quick fix menu Architecture The server uses tree-sitter for robust parsing and maintains an in-memory index of custom elements for fast completion and hover responses. LSP methods are arranged into dedicated go packages for ease of maintenance.\n","link":"https://bennypowers.dev/cem/docs/lsp/","section":"docs","title":"Language Server"},{"body":"Number of runs per tool: 100 Number of files analyzed per run: 45 Benchmark results: lower is better (seconds) : 1.46 @lit-labs/cli 1.46 : 0.82 @custom-elements-manifest/analyzer 0.82 : 0.26 cem generate 0.26 @lit-labs/cli Docs 1.46s Avg Time 52.3KB Avg Output Size 100 Runs Warnings Validation Command npx --yes @lit-labs/cli labs gen --manifest --out data/lit Run Breakdown: Time per Run (seconds) 1.43 1.46 1.49 1.52 1.54 1.57 1100Run # Validation Results 📄 Global schema schema-version-old: validation for manifests with schemaVersion \u003c 2.1.0 may not produce accurate results (version: 1.0.0) 📄 benchmark/components/alert-toast.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass AlertToast → method connectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AlertToast → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AlertToast → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass AlertToast → field styles 📄 benchmark/components/avatar-image.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AvatarImage → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass AvatarImage → method #onError implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AvatarImage → static field styles 📄 benchmark/components/button-element.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ButtonElement → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ButtonElement → static field styles 📄 benchmark/components/clipboard-copy.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ClipboardCopy → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ClipboardCopy → static field styles 📄 benchmark/components/color-picker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ColorPicker → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ColorPicker → method #onInput 📄 benchmark/components/complex-component.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexComponent → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ComplexComponent → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ComplexComponent → field styles 📄 benchmark/components/complex-types.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexTypes → method render 📄 benchmark/components/dark-mode-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DarkModeToggle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DarkModeToggle → method #toggle 📄 benchmark/components/dismiss-button.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DismissButton → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DismissButton → method #dismiss implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass DismissButton → static field styles 📄 benchmark/components/emoji-picker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass EmojiPicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass EmojiPicker → static field styles 📄 benchmark/components/expand-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ExpandToggle → static field styles 📄 benchmark/components/expandable-panel.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandablePanel → method render 📄 benchmark/components/field-label.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FieldLabel → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass FieldLabel → static field styles 📄 benchmark/components/file-uploader.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FileUploader → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass FileUploader → method #onChange 📄 benchmark/components/icon-badge.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass IconBadge → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass IconBadge → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass IconBadge → field styles 📄 benchmark/components/image-gallery.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ImageGallery → method render 📄 benchmark/components/inline-edit.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass InlineEdit → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #startEdit private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onInput private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onBlur implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass InlineEdit → static field styles 📄 benchmark/components/keyboard-shortcut.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass KeyboardShortcut → method connectedCallback lifecycle-web-components: lifecycle method should not be documented in public API\nclass KeyboardShortcut → method disconnectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass KeyboardShortcut → method render 📄 benchmark/components/load-spinner.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass LoadSpinner → method connectedCallback lifecycle-web-components: lifecycle method should not be documented in public API\nclass LoadSpinner → method disconnectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass LoadSpinner → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass LoadSpinner → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass LoadSpinner → field styles 📄 benchmark/components/markdown-viewer.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MarkdownViewer → method render 📄 benchmark/components/message-bubble.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MessageBubble → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass MessageBubble → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass MessageBubble → field styles 📄 benchmark/components/multi-slot.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MultiSlot → method render 📄 benchmark/components/no-decorator.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NoDecoratorElement → method render 📄 benchmark/components/notification-banner.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NotificationBanner → method render 📄 benchmark/components/privacy-test.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass PrivacyTest → method render private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass PrivacyTest → static field styles 📄 benchmark/components/progress-circle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ProgressCircle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ProgressCircle → method #color implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ProgressCircle → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ProgressCircle → field styles 📄 benchmark/components/range-slider.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass RangeSlider → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass RangeSlider → method #onInput 📄 benchmark/components/resize-handle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ResizeHandle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ResizeHandle → static field styles 📄 benchmark/components/search-bar.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SearchBar → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass SearchBar → method #onInput 📄 benchmark/components/section-header.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SectionHeader → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SectionHeader → static field styles 📄 benchmark/components/skeleton-block.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SkeletonBlock → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SkeletonBlock → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass SkeletonBlock → field styles 📄 benchmark/components/split-pane.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SplitPane → method render 📄 benchmark/components/star-rating.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StarRating → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass StarRating → method #setRating 📄 benchmark/components/step-progress.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StepProgress → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass StepProgress → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass StepProgress → field styles 📄 benchmark/components/tab-navigation.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TabNavigation → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass TabNavigation → method #select 📄 benchmark/components/tag-list.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TagList → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TagList → static field styles 📄 benchmark/components/text-ticker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TextTicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TextTicker → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass TextTicker → field styles 📄 benchmark/components/theme-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ThemeToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ThemeToggle → static field styles 📄 benchmark/components/toast-stack.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToastStack → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ToastStack → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ToastStack → field styles 📄 benchmark/components/toggle-switch.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToggleSwitch → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ToggleSwitch → method #onToggle 📄 benchmark/components/user-avatar.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserAvatar → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass UserAvatar → static field styles 📄 benchmark/components/user-list.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserList → method render 📄 benchmark/components/visually-hidden.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass VisuallyHidden → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass VisuallyHidden → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass VisuallyHidden → field styles @custom-elements-manifest/analyzer Docs 0.82s Avg Time 66.1KB Avg Output Size 100 Runs Warnings Validation Command npx --yes @custom-elements-manifest/analyzer analyze --outdir data/cea --globs benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.79 0.80 0.81 0.82 0.83 0.84 1100Run # Validation Results 📄 Global schema schema-version-old: validation for manifests with schemaVersion \u003c 2.1.0 may not produce accurate results (version: 1.0.0) 📄 benchmark/components/alert-toast.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AlertToast → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AlertToast → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass AlertToast → field styles 📄 benchmark/components/avatar-image.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AvatarImage → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass AvatarImage → method #onError implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AvatarImage → static field styles 📄 benchmark/components/button-element.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ButtonElement → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ButtonElement → static field styles 📄 benchmark/components/clipboard-copy.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ClipboardCopy → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ClipboardCopy → static field styles 📄 benchmark/components/color-picker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ColorPicker → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ColorPicker → method #onInput 📄 benchmark/components/complex-component.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexComponent → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ComplexComponent → static field styles 📄 benchmark/components/complex-types.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexTypes → method render 📄 benchmark/components/dark-mode-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DarkModeToggle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DarkModeToggle → method #toggle 📄 benchmark/components/dismiss-button.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DismissButton → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DismissButton → method #dismiss implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass DismissButton → static field styles 📄 benchmark/components/emoji-picker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass EmojiPicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass EmojiPicker → static field styles 📄 benchmark/components/expand-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ExpandToggle → static field styles 📄 benchmark/components/expandable-panel.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandablePanel → method render 📄 benchmark/components/field-label.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FieldLabel → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass FieldLabel → static field styles 📄 benchmark/components/file-uploader.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FileUploader → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass FileUploader → method #onChange 📄 benchmark/components/icon-badge.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass IconBadge → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass IconBadge → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass IconBadge → field styles 📄 benchmark/components/image-gallery.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ImageGallery → method render 📄 benchmark/components/inline-edit.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass InlineEdit → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #startEdit private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onInput private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onBlur implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass InlineEdit → static field styles 📄 benchmark/components/keyboard-shortcut.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass KeyboardShortcut → method render 📄 benchmark/components/load-spinner.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass LoadSpinner → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass LoadSpinner → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass LoadSpinner → field styles 📄 benchmark/components/markdown-viewer.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MarkdownViewer → method render 📄 benchmark/components/message-bubble.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MessageBubble → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass MessageBubble → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass MessageBubble → field styles 📄 benchmark/components/multi-slot.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MultiSlot → method render 📄 benchmark/components/no-decorator.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NoDecoratorElement → method render 📄 benchmark/components/notification-banner.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NotificationBanner → method render 📄 benchmark/components/privacy-test.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass PrivacyTest → method render private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass PrivacyTest → static field styles 📄 benchmark/components/progress-circle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ProgressCircle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ProgressCircle → method #color implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ProgressCircle → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ProgressCircle → field styles 📄 benchmark/components/range-slider.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass RangeSlider → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass RangeSlider → method #onInput 📄 benchmark/components/resize-handle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ResizeHandle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ResizeHandle → static field styles 📄 benchmark/components/search-bar.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SearchBar → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass SearchBar → method #onInput 📄 benchmark/components/section-header.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SectionHeader → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SectionHeader → static field styles 📄 benchmark/components/skeleton-block.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SkeletonBlock → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SkeletonBlock → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass SkeletonBlock → field styles 📄 benchmark/components/split-pane.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SplitPane → method render 📄 benchmark/components/star-rating.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StarRating → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass StarRating → method #setRating 📄 benchmark/components/step-progress.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StepProgress → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass StepProgress → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass StepProgress → field styles 📄 benchmark/components/tab-navigation.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TabNavigation → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass TabNavigation → method #select 📄 benchmark/components/tag-list.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TagList → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TagList → static field styles 📄 benchmark/components/text-ticker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TextTicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TextTicker → static field styles 📄 benchmark/components/theme-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ThemeToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ThemeToggle → static field styles 📄 benchmark/components/toast-stack.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToastStack → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ToastStack → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ToastStack → field styles 📄 benchmark/components/toggle-switch.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToggleSwitch → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ToggleSwitch → method #onToggle 📄 benchmark/components/user-avatar.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserAvatar → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass UserAvatar → static field styles 📄 benchmark/components/user-list.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserList → method render 📄 benchmark/components/visually-hidden.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass VisuallyHidden → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass VisuallyHidden → static field styles cem generate Docs 0.26s Avg Time 48KB Avg Output Size 100 Runs Warnings Validation Command cem generate -o data/cem/custom-elements.json benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.25 0.26 0.26 0.26 0.27 0.27 1100Run # Validation Results 📄 benchmark/components/privacy-test.js private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _privateMethod ","link":"https://bennypowers.dev/cem/docs/benchmarks/","section":"docs","title":"Benchmarks"},{"body":"The cem mcp command starts a Model Context Protocol (MCP) server that provides AI-native access to your custom elements manifest data. This enables intelligent HTML generation, component understanding, and design system compliance for AI assistants.\nOverview The MCP server transforms your custom elements manifests into a structured, type-safe interface that AI systems can use to:\nGenerate correct HTML with proper slot and attribute usage Understand component APIs and relationships Provide CSS integration guidance for custom properties and parts Enforce design system guidelines and best practices Validate custom element usage patterns and manifest compliance Security and Limits For security and optimal AI performance, the server enforces a 2000 character limit on description fields. Descriptions exceeding this limit are automatically truncated. This limit can be customized via configuration file or command line flags.\nFor best practices on writing effective descriptions within this limit, see Writing Effective Descriptions .\nQuick Start # Start MCP server for current workspace cem mcp The server uses stdio transport and automatically discovers manifests from your workspace.\nMCP Resources The server provides several resource types that AI systems can access:\nURI Description cem://schema Returns the JSON schema for custom elements manifests, enabling validation and understanding of manifest structure. cem://packages Provides package discovery and overview of available manifest packages in the workspace. cem://elements Returns summaries of all available elements with their capabilities and basic metadata. cem://element/{tagName} Returns detailed information about a specific element, including all attributes, slots, events, CSS properties, parts, and states. cem://element/{tagName}/attributes Focused attribute documentation with type constraints, valid values, and usage patterns. cem://element/{tagName}/slots Content guidelines and accessibility considerations for slot usage. cem://element/{tagName}/events Event triggers, data payloads, and JavaScript integration patterns. cem://element/{tagName}/css/parts CSS parts styling guidance for targeted element customization. cem://element/{tagName}/css/custom-properties CSS custom properties documentation for comprehensive theming. cem://element/{tagName}/css/states CSS custom states documentation for interactive styling patterns. cem://guidelines Provides design system guidelines and best practices for component usage. cem://accessibility Returns accessibility patterns and validation rules for component compliance. MCP Tools The server provides core action tools that work with the declarative resource \u0026ldquo;database\u0026rdquo;. Progressive disclosure is handled by the comprehensive resource system, while tools focus on concrete actions:\nHTML Generation Tool: generate_html\nGenerate correct HTML structure with proper slots and attributes using manifest data.\nParameter Type Required Description tagName string ✅ Element to generate HTML for attributes object Attribute values to include content object Slot content mapping HTML Validation Tool: validate_html\nValidates custom element usage based on manifest guidelines and best practices. Focuses on custom element-specific issues like slot content guidelines, attribute conflicts, and content/attribute redundancy.\nParameter Type Required Description html string ✅ HTML content to validate tagName string Focus validation on specific element context string Validation context for custom elements Validation Types:\nSlot Content Guidelines: Validates slotted content against manifest slot descriptions Attribute Conflicts: Detects contradictory attribute combinations (e.g., loading=\u0026quot;eager\u0026quot; + lazy=\u0026quot;true\u0026quot;) Content/Attribute Redundancy: Identifies when slot content overrides attribute values Manifest Compliance: Ensures custom elements are used according to their documented constraints Usage Once connected, AI assistants can access your component information through natural language:\n\u0026ldquo;What custom elements are available?\u0026rdquo; - Lists all components \u0026ldquo;Tell me about the my-button component\u0026rdquo; - Shows attributes, slots, CSS APIs \u0026ldquo;Generate a form with my-input and my-button\u0026rdquo; - Creates valid HTML \u0026ldquo;How do I style the my-card component?\u0026rdquo; - Provides CSS guidance AI Client Configuration Claude Desktop { \u0026#34;mcpServers\u0026#34;: { \u0026#34;cem\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;cem\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;mcp\u0026#34;] } } } Other Clients The CEM MCP server works with any MCP-compatible AI client:\nClaude Code - See Claude Code MCP docs Cursor - See Cursor MCP integration Continue.dev - See Continue MCP setup Custom clients - See MCP specification How It Works The CEM MCP server works by transforming your custom elements manifests into AI-accessible resources and tools:\n📊 Manifest Discovery - Automatically finds and loads custom elements manifests from your workspace 🔗 Resource API - Exposes component information through structured URIs (like cem://element/{tagName}/attributes) ⚡ Action Tools - Provides concrete capabilities like HTML generation and validation 🧠 Intelligent Context - Combines your component data with rich context to help AI make informed decisions The server acts as a bridge between your component definitions and AI systems, enabling intelligent code generation while respecting your documented component constraints and guidelines.\nDebugging MCP Inspector The MCP Inspector provides interactive debugging and testing capabilities for MCP servers. Use it to debug the CEM MCP server:\n# Install MCP Inspector npm install -g @modelcontextprotocol/inspector # Debug CEM MCP server mcp-inspector cem mcp The inspector provides:\nInteractive testing - Call tools and resources directly in a web UI Real-time logs - View server initialization and runtime messages Schema validation - Test resource URIs and tool parameters Message inspection - Debug MCP protocol communication Debugging Specific Projects Use the --package flag to debug different project directories:\n# Debug specific project, with custom description limit mcp-inspector cem mcp --package /path/to/project --max-description-length 5000 Verbose Logging Enable detailed logging for development:\n# Enable verbose output cem mcp --verbose # Or with MCP Inspector mcp-inspector cem mcp --verbose Troubleshooting Common Issues Server won\u0026rsquo;t start:\n# Check workspace has manifests cem list # Verify workspace structure cem validate No elements found:\n# Generate manifests first cem generate # Check workspace context ls custom-elements.json package.json Connection issues:\nEnsure the cem mcp command runs without errors Check that manifest files exist in your workspace Verify your AI client is configured for stdio transport Inspector shows empty resources:\n# Verify manifests are discoverable cem list --verbose # Test specific project directory mcp-inspector cem mcp --package ./path/to/project See Also Writing Effective Descriptions - Guidelines for AI-friendly component documentation Usage Examples - Comprehensive usage examples API Reference - Complete API documentation ","link":"https://bennypowers.dev/cem/docs/mcp/","section":"docs","title":"MCP Server"},{"body":"The cem command-line tool has several commands to help you generate and query Custom Elements Manifests.\nGenerate Analyze your source code and automatically create a comprehensive custom-elements.json manifest file that documents all your custom elements and their APIs.\nList Query and inspect your custom elements manifest with powerful filtering and display options to explore your component APIs interactively.\nSearch Find elements, attributes, methods, and other API features across your entire project using flexible keyword and regex pattern matching.\nValidate Ensure your custom elements manifest files conform to the official schema and catch potential issues before publishing.\n","link":"https://bennypowers.dev/cem/docs/commands/","section":"docs","title":"Commands"},{"body":"When using the cem mcp server, the quality of your custom elements manifest descriptions directly impacts how well AI systems can understand and use your components. This guide shows you how to write descriptions that work excellently with both human developers and AI assistants.\nWhy Description Quality Matters AI language models use your manifest descriptions to:\nGenerate proper HTML with correct attributes and slots Suggest appropriate component usage patterns Validate accessibility compliance Provide contextual recommendations Understand component relationships and hierarchies Well-written descriptions enable AI to make intelligent decisions about component usage, while poor descriptions lead to incorrect or suboptimal code generation.\nDescription Length Limits The CEM MCP server enforces a 2000 character limit on description fields to ensure optimal AI performance and prevent abuse. Descriptions exceeding this limit are automatically truncated with \u0026ldquo;\u0026hellip;\u0026rdquo; appended.\nThis limit applies to:\nElement descriptions Attribute descriptions Slot descriptions CSS property descriptions Event descriptions CSS part descriptions Best Practice: Most effective descriptions are much shorter than 2000 characters. Aim for 200-400 characters for core information, using the full limit only for complex components requiring extensive guidance.\nCustomizing Length Limits For projects requiring different description length limits, you can configure this in your CEM configuration file:\nmcp: maxDescriptionLength: 5000 Or use the command line flag:\ncem mcp --max-description-length 5000 Declarative Tool Architecture The CEM MCP server uses a declarative tool framework that transforms your manifest data into intelligent, context-aware responses for AI systems. Understanding this architecture helps you write more effective descriptions.\nHow the Declarative Framework Works The MCP server uses a data-driven approach where tools are defined through YAML configuration rather than hardcoded logic:\nData Fetchers: Extract specific information from your manifests using JSON path queries Template Rendering: Combine manifest data with Go templates to create rich, contextual responses Schema Integration: Provide JSON schema definitions that help AI understand component constraints Intelligent Context: Present comprehensive information while letting AI make smart decisions What This Means for Your Descriptions The declarative framework amplifies the impact of your manifest descriptions by:\nContextualizing your descriptions with related schema information Combining element descriptions with attribute, slot, and CSS property details Presenting comprehensive usage patterns derived from your component API definitions Enabling AI to understand relationships between different parts of your component Key insight: Your descriptions don\u0026rsquo;t work in isolation. They\u0026rsquo;re combined with type information, schema definitions, and usage patterns to create comprehensive guidance that helps AI make intelligent decisions about component usage.\nWriting for the Declarative Framework Since the framework combines multiple data sources, focus your descriptions on:\nPurpose and Context: What the component/attribute/slot is for, not just what it is Usage Guidelines: When and how to use it effectively Relationships: How it works with other component features Constraints: What to avoid or be careful about The framework will automatically combine this with:\nType definitions and valid values Schema descriptions and relationships Usage patterns from your component API Cross-component consistency information General Principles 1. Use RFC 2119 Keywords for Actionable Guidelines The CEM MCP server extracts actionable guidelines from your descriptions by looking for RFC 2119 keywords. This creates structured guidance that AI systems can use for intelligent code generation and validation.\nThe guideline extraction system looks for these keywords in your descriptions:\nMUST / must - Required behavior or values SHOULD / should - Recommended practices AVOID / avoid - Discouraged patterns USE / use - Preferred approaches Effective RFC 2119 Usage You can use either uppercase or lowercase - both work equally well:\n/** * Button size affecting touch targets and visual hierarchy. * Must be \u0026#39;large\u0026#39; for primary mobile actions to meet accessibility requirements. * Should use \u0026#39;medium\u0026#39; for standard desktop interfaces. * Avoid \u0026#39;small\u0026#39; for important actions as it reduces accessibility. */ @property() size: \u0026#39;small\u0026#39; | \u0026#39;medium\u0026#39; | \u0026#39;large\u0026#39; = \u0026#39;medium\u0026#39; This generates both type suggestions (\u0026lsquo;small\u0026rsquo;, \u0026lsquo;medium\u0026rsquo;, \u0026rsquo;large\u0026rsquo;) and guideline recommendations from the must/should/avoid statements.\nLess Effective Patterns /** * This property controls the button size. Different sizes are available * for different use cases. Pick the one that works best. */ @property() size: \u0026#39;small\u0026#39; | \u0026#39;medium\u0026#39; | \u0026#39;large\u0026#39; = \u0026#39;medium\u0026#39; While the type information is extracted, no guidelines are generated because there are no RFC 2119 keywords.\n2. Write for Both Humans and AI Good descriptions serve dual purposes:\nHuman developers need clear, concise information for manual coding AI systems need structured, actionable guidance for automatic generation A navigation button that supports keyboard interaction and screen readers. Use for primary actions in forms and dialogs. ✅ Good: Clear and actionable A custom button element with click handling ❌ Poor: Too brief and technical 3. Include Usage Context and Guidelines AI systems benefit from understanding when and how to use components:\nA card container for grouping related content. Should include a header slot for titles and supports elevation levels 0-5 for visual hierarchy. Use sparingly to avoid visual clutter. ✅ Good: Includes context and guidelines A card component with slots ❌ Poor: Just describes what it is 4. Emphasize Accessibility Requirements Since accessibility is a core priority, include accessibility guidance in descriptions:\nAn interactive toggle button that announces state changes to screen readers. Must include aria-pressed attribute and supports keyboard activation with Space or Enter keys. ✅ Good: Accessibility-focused A toggle button component ❌ Poor: No accessibility information 5. Combine Types and Guidelines for Maximum AI Effectiveness The most AI-friendly approach combines clear TypeScript union types with guideline-rich descriptions:\n/** * Visual style variant affecting semantic meaning and accessibility. * Use \u0026#39;primary\u0026#39; for main call-to-action buttons in forms and dialogs. * Use \u0026#39;secondary\u0026#39; for supporting actions that complement primary actions. * Use \u0026#39;danger\u0026#39; for destructive actions that require user confirmation. * Avoid using \u0026#39;danger\u0026#39; for non-destructive actions to prevent confusion. * Each variant provides appropriate color contrast for accessibility. */ @property() variant: \u0026#39;primary\u0026#39; | \u0026#39;secondary\u0026#39; | \u0026#39;danger\u0026#39; | \u0026#39;ghost\u0026#39; = \u0026#39;primary\u0026#39; This provides:\nType suggestions: AI understands all valid values from the union type Usage guidelines: When to use each variant (extracted from RFC 2119 keywords) Accessibility context: Color contrast considerations Anti-patterns: What to avoid and why Declarative Tool Integration The declarative framework provides several specialized tools that present your descriptions in focused, context-aware formats. Understanding how these tools work helps you write descriptions that shine in each context.\nElement-Focused Resources The framework includes specialized declarative resources for different aspects of your components:\ncem://element/{tagName}/attributes: Focused attribute documentation with type constraints cem://element/{tagName}/slots: Content guidelines and accessibility considerations for slots cem://element/{tagName}/events: Event triggers, data payloads, and integration patterns cem://element/{tagName}/css/parts: CSS parts styling guidance for targeted customization cem://element/{tagName}/css/custom-properties: CSS custom properties documentation for theming cem://element/{tagName}/css/states: CSS custom states documentation for interactive styling How Resources Present Your Content Each resource combines your descriptions with relevant schema information:\nYour Description + Type Information + Schema Context = Rich AI Guidance Example: For an attribute description like \u0026ldquo;Button size affecting accessibility\u0026rdquo;, the cem://element/{tagName}/attributes resource combines this with:\nUnion type values ('small' | 'medium' | 'large') Default value information ('medium') Schema descriptions for size concepts Cross-component consistency patterns Result: AI receives comprehensive guidance like:\n\u0026ldquo;Button size affects touch targets and accessibility. Use \u0026lsquo;small\u0026rsquo; for compact layouts, \u0026lsquo;medium\u0026rsquo; for standard interfaces, \u0026rsquo;large\u0026rsquo; for mobile-first actions. Each size ensures minimum touch target requirements for accessibility compliance.\u0026rdquo;\nWriting for Resource Specialization Since resources focus on specific aspects, tailor your descriptions accordingly:\nFor Element Descriptions (used by element_details) Focus on overall purpose, main use cases, and key relationships:\n/** * An accessible card container for grouping related content with semantic markup. * Use for dashboard widgets, content previews, and information grouping. * Supports responsive design and maintains proper heading hierarchy. */ For Attribute Descriptions (enhanced by cem://element/{tagName}/attributes) Focus on purpose, constraints, and usage context:\n/** * Controls card prominence in visual hierarchy. Use \u0026#39;flat\u0026#39; for embedded content, * \u0026#39;raised\u0026#39; for interactive cards, \u0026#39;floating\u0026#39; for modal-style overlays. */ elevation: \u0026#39;flat\u0026#39; | \u0026#39;raised\u0026#39; | \u0026#39;floating\u0026#39; For Slot Descriptions (used by cem://element/{tagName}/slots) Focus on content types, accessibility, and relationships:\n/** * Card header area for titles and actions. Should contain heading elements (h2-h4) * to maintain document structure. Avoid interactive elements that conflict with * card-level actions. Announced first by screen readers. */ The declarative framework ensures that your focused descriptions are automatically enhanced with relevant schema information, type constraints, and cross-component patterns to provide comprehensive AI guidance.\nElement Descriptions Element descriptions should answer: What is this component and when should I use it?\nStructure Your Element Descriptions Use this pattern for comprehensive element descriptions:\n[Component Purpose] [Accessibility Features] [Usage Guidelines] [Context Information] Examples by Component Type Interactive Components (Buttons, Inputs, Controls) A primary action button with built-in loading states and accessibility features. Automatically includes proper ARIA attributes and keyboard support. Use for important actions like form submission, confirmation dialogs, and primary navigation. Supports variant styling for different contexts.\nKey elements:\nPurpose: \u0026ldquo;primary action button\u0026rdquo; Accessibility: \u0026ldquo;ARIA attributes and keyboard support\u0026rdquo; Usage context: \u0026ldquo;form submission, confirmation dialogs\u0026rdquo; Features: \u0026ldquo;loading states\u0026rdquo;, \u0026ldquo;variant styling\u0026rdquo; Layout Components (Cards, Containers, Grids) A flexible content container with semantic markup for grouping related information. Includes slots for header, body, and footer content with proper heading hierarchy. Use for dashboard widgets, product listings, and content previews. Supports responsive design and maintains accessibility across screen sizes.\nKey elements:\nPurpose: \u0026ldquo;content container for grouping\u0026rdquo; Structure: \u0026ldquo;slots for header, body, footer\u0026rdquo; Semantic info: \u0026ldquo;proper heading hierarchy\u0026rdquo; Usage examples: \u0026ldquo;dashboard widgets, product listings\u0026rdquo; Responsive: \u0026ldquo;maintains accessibility across screen sizes\u0026rdquo; Navigation Components (Menus, Tabs, Breadcrumbs) An accessible tab navigation component that manages focus and announces selections to screen readers. Implements WCAG navigation patterns with arrow key support and automatic ARIA relationships. Use for organizing content into logical sections within a single view.\nKey elements:\nAccessibility: \u0026ldquo;manages focus\u0026rdquo;, \u0026ldquo;announces selections\u0026rdquo;, \u0026ldquo;WCAG patterns\u0026rdquo; Interaction: \u0026ldquo;arrow key support\u0026rdquo;, \u0026ldquo;ARIA relationships\u0026rdquo; Usage context: \u0026ldquo;organizing content into logical sections\u0026rdquo; Attribute Descriptions Attribute descriptions should answer: What does this control and how should I use it?\nInclude Type Information and Valid Values @property() variant: \u0026#39;primary\u0026#39; | \u0026#39;secondary\u0026#39; | \u0026#39;danger\u0026#39; | \u0026#39;ghost\u0026#39; Button visual style and semantic meaning. Use 'primary' for main actions, 'secondary' for supporting actions, 'danger' for destructive actions, and 'ghost' for subtle actions. Affects color contrast and accessibility announcements. ✅ Good: Complete attribute information Button style ❌ Poor: Minimal information Explain Impact and Usage Context @property() size: \u0026#39;small\u0026#39; | \u0026#39;medium\u0026#39; | \u0026#39;large\u0026#39; Controls button dimensions and touch target size for accessibility. Use 'small' for compact layouts, 'medium' for standard interfaces, 'large' for mobile-first or prominent actions. Ensures minimum 44px touch target on mobile devices. ✅ Good: Explains impact and context Include Default Behavior @property({ type: Boolean }) loading = false Shows loading spinner and disables interaction during async operations. Automatically announces loading state to screen readers. Set to true during form submission or data fetching to prevent duplicate actions. ✅ Good: Explains default and when to change Slot Descriptions Slot descriptions should answer: What content belongs here and how should it be structured?\nDescribe Expected Content Types For a header slot:\nCard header content, typically a heading element (h2-h4) or title text. Should establish the card's purpose and maintain proper heading hierarchy. Avoid interactive elements that might conflict with card-level actions. ✅ Good: Specific content guidance Header content ❌ Poor: Generic description Include Accessibility Considerations For a card element\u0026rsquo;s action slot:\nPrimary action area for buttons or links. Content should be descriptive for screen readers (avoid 'click here' or 'read more'). Interactive elements will receive proper focus management within the card context. ✅ Good: Accessibility-aware slot description Explain Content Relationships For a card element\u0026rsquo;s default slot:\nMain card content area for body text, lists, or media. Content should complement the header and any action elements. Will be announced as the primary card content by screen readers after the header. ✅ Good: Explains how content works together CSS Property Descriptions CSS property descriptions should answer: What visual aspect does this control and how does it fit the design system?\nLink to Design System Concepts --card-elevation: 2px; Controls card shadow depth using design system elevation scale. Maps to elevation tokens 0-5 where 0 is flat and 5 is highest prominence. Affects both visual hierarchy and accessibility by indicating interactive priority. ✅ Good: Design system integration Card shadow depth ❌ Poor: No context or guidance Explain Visual and Functional Impact --button-radius: 4px; Border radius for button corners affecting visual style and brand consistency. Use design system radius tokens (--radius-sm, --radius-md, --radius-lg) for consistency. Impacts touch target perception on mobile devices. ✅ Good: Visual and functional explanation Button border radius ❌ Poor: No usage guidance Event Descriptions Event descriptions should answer: When does this fire and what data does it provide?\nDescribe Trigger Conditions and Data For a selection-change event:\nFired when user selects or deselects items, including keyboard and mouse interactions. Event detail contains selectedItems array and previousSelection for accessibility announcements. Debounced to prevent excessive firing during rapid selection changes. ✅ Good: Complete event information Fired when selection changes ❌ Poor: No detail about triggers or data Include Accessibility Information For an expand-toggle event:\nFired when collapsible content expands or collapses. Event detail includes expanded state and target element for screen reader announcements. Use to coordinate ARIA attributes and manage focus when content visibility changes. ✅ Good: Accessibility integration Fired when expanding or collapsing ❌ Poor: No accessibility context CSS Parts and States CSS Parts: Describe Styling Purpose \u0026lt;input part=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; The input field element for styling text appearance, borders, and focus states. Inherits form-level styling but can be customized for specific use cases. Maintain sufficient color contrast for accessibility. ✅ Good: Clear styling guidance Input field part ❌ Poor: No styling guidance or context CSS States: Explain Behavioral Context @property({ type: Boolean, reflect: true }) loading = false; Applied during async operations when the component is waiting for data or processing requests. Use to style loading indicators and adjust interaction states. Should provide visual feedback while maintaining accessibility. ✅ Good: Behavioral context Loading state ❌ Poor: No behavioral guidance or usage context Common Patterns and Anti-Patterns ✅ Good Patterns Action-oriented language: \u0026ldquo;Use for\u0026hellip;\u0026rdquo;, \u0026ldquo;Include\u0026hellip;\u0026rdquo;, \u0026ldquo;Ensure\u0026hellip;\u0026rdquo; Context information: When, where, and why to use Accessibility integration: Screen reader behavior, keyboard support Design system alignment: Token usage, consistency guidelines Error prevention: Common mistakes and how to avoid them ❌ Anti-Patterns Implementation details: Avoid technical internals that don\u0026rsquo;t help usage Vague language: \u0026ldquo;Customizes appearance\u0026rdquo; instead of specific guidance Missing accessibility: No mention of screen reader or keyboard behavior No usage context: Describing what something is without when to use it Inconsistent terminology: Different names for the same concepts Testing Your Descriptions Manual Review Checklist Purpose is clear: A developer new to the component understands its role Usage context provided: When and where to use the component Accessibility included: Screen reader and keyboard behavior mentioned Examples or guidelines: Specific guidance for proper usage Design system integration: How it fits with other components Error prevention: Common mistakes identified and avoided AI Testing Use the cem mcp server to test your descriptions:\nAsk AI to generate HTML using your component Request attribute suggestions for different contexts Check if accessibility recommendations are appropriate Verify that generated examples follow your intended usage patterns The AI should be able to make intelligent decisions based solely on your manifest descriptions. If it generates inappropriate usage, consider refining your descriptions for clarity and completeness.\nComplete Example: Complex Component Documentation Here\u0026rsquo;s a comprehensive example showing how to properly document a complex component with all its APIs:\nMulti-Select Component: Full Documentation This example demonstrates complete documentation for a sophisticated multi-select component with rich interactions, accessibility features, and extensive customization options.\n/** * An accessible multi-select dropdown with search, keyboard navigation, and bulk operations. * Implements WCAG 2.1 AA standards with comprehensive screen reader support and keyboard * interaction patterns. Use for selection from large datasets where users need to choose * multiple related items, such as tag selection, user assignment, or category filtering. * * @event selection-change - Fired when selection changes through any interaction method (click, keyboard, programmatic). Event detail includes complete selection state and the specific change that occurred. Use for form validation, dependent field updates, or analytics tracking. Debounced during rapid keyboard navigation to prevent excessive firing. * @event search-input - Fired when user types in search field (when searchable is true). Event detail contains current search query and number of matching options. Use for external filtering, analytics, or implementing custom search behavior. Fires after built-in filtering is applied. * @event dropdown-toggle - Fired when dropdown opens or closes. Event detail indicates new state and what triggered the change. Use for coordinating with external UI elements, implementing custom positioning, or managing page-level focus. Essential for modal-style behaviors. * @event max-reached - Fired when user attempts to select beyond max-selections limit. Use to show helpful error messages or suggest alternative actions. Event is fired before selection is rejected, allowing for custom handling or user education. * * @cssstate open - Applied when dropdown is expanded. Use for styling state transitions, positioning adjustments, or coordinating with external elements. Helps manage z-index and overlay behaviors. * @cssstate searching - Applied when user is actively typing in search field. Use for loading indicators, highlighting matched text, or adjusting dropdown layout. Provides visual feedback during search operations. * @cssstate max-reached - Applied when maximum selection limit is reached. Use for visual feedback, disabling remaining options, or showing helpful messaging. Should clearly communicate the constraint to users. * @cssstate required-empty - Applied when component is required but has no selections. Use for error styling, validation messaging, or form submission prevention. Should clearly indicate the validation state. */ @customElement(\u0026#39;multi-select\u0026#39;) export class MultiSelectElement extends LitElement { static styles = css` :host { /** * Controls component width. Use design system width tokens or specific * measurements. Affects dropdown positioning and text wrapping behavior. * Consider content length and container constraints when setting. */ --multi-select-width: auto; /** * Maximum height for the dropdown options list. When exceeded, the list * becomes scrollable with keyboard navigation support. Use viewport-relative * units for responsive behavior. Recommended range: 200px to 60vh for optimal usability. */ --multi-select-max-height: 300px; /** * Background color for selected item tags (when selection-display=\u0026#39;tags\u0026#39;). * Should maintain sufficient contrast with text color for accessibility. * Use semantic colors from design system that indicate selection state clearly. */ --selection-tag-color: var(--color-primary-100); /** * Background color for option hover state. Must meet WCAG contrast requirements * against option text. Provides visual feedback for keyboard and mouse navigation. * Should be distinct from selection and focus states. */ --option-hover-bg: var(--color-gray-100); /** * Border radius for dropdown container. Use design system radius tokens for * consistency. Affects visual integration with page design and brand consistency. * Consider relationship to trigger element styling. */ --dropdown-border-radius: var(--radius-md); } `; /** * Placeholder text shown when no selections are made. Should be descriptive * and action-oriented (e.g., \u0026#39;Select team members\u0026#39; rather than \u0026#39;Choose options\u0026#39;). * Announced by screen readers when the component receives focus. */ @property({ type: String }) placeholder = \u0026#39;Select options...\u0026#39;; /** * Enables search/filter functionality within the dropdown. When true, users can * type to filter available options, improving usability for large option sets. * Search is case-insensitive and matches partial strings. Essential for lists * with more than 10 options. */ @property({ type: Boolean }) searchable = false; /** * Maximum number of items that can be selected. When limit is reached, remaining * options become disabled with appropriate ARIA states. Use to prevent overwhelming * interfaces or enforce business rules. Value of 0 means unlimited selections. */ @property({ type: Number, attribute: \u0026#39;max-selections\u0026#39; }) maxSelections = 0; /** * Marks the component as required for form validation. Displays visual indicator * and updates ARIA attributes for screen readers. Prevents form submission when * no selections are made. Should be paired with clear error messaging. */ @property({ type: Boolean }) required = false; /** * Disables all interaction with the component. Sets appropriate ARIA states and * visual styling. Use for read-only states or when dependent form fields haven\u0026#39;t * been completed. Maintains selection visibility for context. */ @property({ type: Boolean }) disabled = false; /** * Controls layout density and information display. \u0026#39;default\u0026#39; shows standard spacing * and basic option text. \u0026#39;compact\u0026#39; reduces spacing for dense interfaces. \u0026#39;detailed\u0026#39; * shows additional option metadata and descriptions. Choose based on interface * density and content complexity. */ @property({ type: String }) variant: \u0026#39;default\u0026#39; | \u0026#39;compact\u0026#39; | \u0026#39;detailed\u0026#39; = \u0026#39;default\u0026#39;; /** * How selected items are displayed in the closed state. \u0026#39;tags\u0026#39; shows individual * removable chips (best for \u0026lt;= 5 selections). \u0026#39;count\u0026#39; shows summary like \u0026#39;3 selected\u0026#39; * (best for large selections). \u0026#39;list\u0026#39; shows comma-separated names (best for 2-4 * selections). Automatically adjusts for accessibility and screen space. */ @property({ type: String, attribute: \u0026#39;selection-display\u0026#39; }) selectionDisplay: \u0026#39;tags\u0026#39; | \u0026#39;count\u0026#39; | \u0026#39;list\u0026#39; = \u0026#39;tags\u0026#39;; render() { return html` \u0026lt;!-- description: \u0026gt; Main clickable area that opens the dropdown. Style for brand consistency and clear affordance. Includes focus indicators and disabled states. Should maintain minimum 44px touch target for mobile accessibility. --\u0026gt; \u0026lt;div part=\u0026#34;trigger\u0026#34;\u0026gt; \u0026lt;!-- description: \u0026gt; Container for displaying selected items. Layout varies based on selection-display attribute. Style for clear visual hierarchy and easy scanning. Handles overflow with appropriate text truncation. --\u0026gt; \u0026lt;div part=\u0026#34;selections\u0026#34;\u0026gt; \u0026lt;!-- Selected items display --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- summary: Dropdown container including search, options, and footer areas. description: \u0026gt; Handles positioning, shadows, and border styling. Consider z-index stacking context and responsive positioning behavior. --\u0026gt; \u0026lt;div part=\u0026#34;dropdown\u0026#34; ?hidden=\u0026#34;${!this.open}\u0026#34;\u0026gt; ${!this.searchable ? \u0026#39;\u0026#39; : html` \u0026lt;!-- summary: Search input field within dropdown (when searchable). description: \u0026gt; Style for clear focus states and placeholder visibility. Should integrate seamlessly with dropdown design while remaining clearly functional. --\u0026gt; \u0026lt;input part=\u0026#34;search-input\u0026#34; type=\u0026#34;search\u0026#34; placeholder=\u0026#34;Search options...\u0026#34;\u0026gt;`} \u0026lt;!-- summary: Optional header content above the options list description: \u0026gt; Use for category labels, action buttons (like \u0026#39;Select All\u0026#39;), or contextual help. Should not contain form controls that conflict with option selection. Announced as part of dropdown context by screen readers. --\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;div class=\u0026#34;options-container\u0026#34;\u0026gt; \u0026lt;!-- summary: Default slot for option elements. description: \u0026gt; Should contain option elements with value attributes and descriptive text content. Options support disabled state and optional description text. Maintain semantic markup for screen readers - each option should be self-contained and descriptive. --\u0026gt; \u0026lt;!-- description: \u0026gt; Individual option elements within the list. Style for clear selection states, hover feedback, and disabled appearance. Must maintain accessibility contrast requirements across all states. --\u0026gt; \u0026lt;slot part=\u0026#34;option\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;!-- summary: Content shown when no options match description: \u0026gt; Content shown when no options match current search or when options list is empty. Should provide helpful guidance or alternative actions. Include clear messaging about search refinement or data loading states. Will be announced by screen readers when displayed. --\u0026gt; \u0026lt;slot name=\u0026#34;empty-state\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- summary: Footer content below options list description: \u0026gt; Ideal for summary information (\u0026#39;X of Y selected\u0026#39;), action buttons, or links to manage the option set externally. Maintains focus context within the dropdown for keyboard navigation. --\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- summary: Individual selection chips when selection-display=\u0026#39;tags\u0026#39; description: \u0026gt; Individual selection chips (when selection-display=\u0026#39;tags\u0026#39;). Include close button styling and hover states. Should be easily scannable and clearly removable for keyboard users. --\u0026gt; \u0026lt;div part=\u0026#34;selected-tag\u0026#34; ?hidden=\u0026#34;${!this.selected}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; `; } } Key Documentation Patterns Demonstrated This example showcases several critical documentation patterns:\nComprehensive Context: Each description explains not just what something does, but when and why to use it Accessibility Integration: Every interactive element includes accessibility considerations and screen reader behavior Design System Alignment: CSS properties reference design tokens and explain visual hierarchy Error Prevention: Descriptions anticipate common mistakes and provide guidance Usage Scaling: Recommendations change based on data size and interface density Progressive Enhancement: Features work together but can be used independently Following these comprehensive documentation patterns ensures your custom elements manifest provides rich, actionable information that enables both human developers and AI systems to use your components correctly, accessibly, and effectively. The key is balancing thoroughness with clarity, always prioritizing the information needed for proper implementation.\n","link":"https://bennypowers.dev/cem/docs/mcp/writing-descriptions/","section":"docs","title":"Writing Effective Descriptions for AI"},{"body":"Contributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm . Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\nContributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm . Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\n","link":"https://bennypowers.dev/cem/docs/contributing/","section":"docs","title":"Contributing"},{"body":"","link":"https://bennypowers.dev/cem/categories/","section":"categories","title":"Categories"},{"body":"cem The blazing-fast CLI tool for generating and working with Custom Elements Manifests . {.subheading}\nUse cem to generate , validate , and query custom elements manifests. Then, use the built-in LSP and MCP servers to activate powerful, AI-native editor features like hover documentation, autocomplete, and more.\nnpm install --save-dev @pwrs/cem Get Started Read the Docs ","link":"https://bennypowers.dev/cem/","section":"","title":"cem"},{"body":"Welcome to the documentation for cem. Here you\u0026rsquo;ll find everything you need to get started with and master the tool.\nKey Sections Installation : Get cem up and running on your system. Language Server Protocol : IDE features for custom elements with intelligent autocomplete and hover documentation. Commands : A detailed reference for every command. Benchmarks : Performance metrics for the analyzer. Contributing : Learn how you can help improve cem. ","link":"https://bennypowers.dev/cem/docs/","section":"docs","title":"Documentation"},{"body":" Generates CEM files from source code using syntax analysis powered by go and tree-sitter . Identifies custom elements, classes, variables, functions, and exports. Supports elements written in idiomatic style using Lit and TypeScript, with a @customElement decorator, and @property decorators on class fields. cem generate best supports LitElements written in idiomatic style with TypeScript decorators. There is rudimentary support for extends HTMLElement, but it is not a high priority for development. If you need something more specific open an issue . JSDoc Use JSDoc comments to add metadata to your element classes, similar to other tools. Add a description by separating the name of the item with -\n@attr / @attribute — Custom element attributes @csspart — CSS shadow parts. See Slots and Parts @cssprop / @cssproperty — Custom CSS properties @cssstate — Custom CSS states @demo — Demo URL @deprecated — Marks a feature or member as deprecated @event — Custom events dispatched by the element @slot — Named or default slots. See Slots and Parts @summary — Short summary for documentation See the generate test fixtures directory for examples\nSlots and Parts cem automatically detects \u0026lt;slot\u0026gt; elements and part attributes in your element’s render() template, merging them with any information provided via JSDoc. You can also document slots and parts inline in your template HTML using HTML comments. This helps in documenting them for your users, but is not required to detect them.\nIf the comment is a plain string, it will be used as the description for the element. In cases where an element is both a slot and a part, the description will only be applied to the slot. For more detailed documentation, you can use YAML inside the comment. Markdown is supported in all HTML comment documentation. Use a backslash (\\) to escape backticks. Examples Plain String Comment A simple comment will be treated as the description. Markdown content is supported and encouraged.\n\u0026lt;!-- This is the **default** `slot`. --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; YAML Comment For more complex metadata, use YAML syntax.\n\u0026lt;!-- summary: The main slot for content description: | This slot displays user-provided content. Supports multiline **markdown**. e.g. `code` deprecated: true --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; Documenting Slots and Parts together When an element is both a slot and a part, you can document both in a single comment.\n\u0026lt;!-- slot: summary: The `info` slot part: summary: The `info-part` part --\u0026gt; \u0026lt;slot name=\u0026#34;info\u0026#34; part=\u0026#34;info-part\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; When including inline markdown `code` in your comments in lit-html templates, you will need to escape the backticks in the comment. CSS Custom Properties Supports CSS Custom Properties by scanning css files and css tagged-template-literals. cem also discovers properties defined in :host rules.\nCustom properties beginning with _ will be ignored (treated as \u0026ldquo;private\u0026rdquo;) e.g. var(--_private) If you provide a Design Tokens Community Group format module (JSON) to cem via the --design-tokens flag, cem will add metadata from your design system to any matching css variables it finds in your elements You can use jsdoc-like comment syntax before each var call to document your variables When both user comments and design token descriptions exist for the same CSS custom property, cem uses the user\u0026rsquo;s variable description first, then the design token\u0026rsquo;s description, separated by two new lines. Example :host { /** * A property defined on the host * @summary The host\u0026#39;s custom property */ --host-property: red; color: /** * custom color for use in this element * @summary color * @deprecated just use the `color` property */ var(--custom-color); border: 1px solid /** Border color of the element */ var(--border-color); } When you have a declaration where the LHS and RHS both contain CSS custom properties, you have to position your comments so that they target the correct variable:\nGood:\n/** comment for --a */ color: var(--a); /** comment for --b */ --b: blue; /** comment for --c */ --c: /** comment for --d */ var(--d); Bad:\n/** comment for --d */ --c: var(--d); JSON Output Format The generated manifest uses Go\u0026rsquo;s JSON marshaling, which escapes HTML-sensitive characters for security reasons. Characters like \u0026lt; and \u0026gt; are converted to \\u003c and \\u003e respectively to prevent XSS attacks when JSON is embedded in HTML script tags.\nThis means CSS syntax values in your manifest will appear escaped:\n{ \u0026#34;name\u0026#34;: \u0026#34;--primary-color\u0026#34;, \u0026#34;syntax\u0026#34;: \u0026#34;\\u003ccolor\\u003e\u0026#34; } This is the expected behavior and doesn\u0026rsquo;t affect the functionality of the manifest. Tools consuming the manifest should handle these standard JSON escape sequences correctly.\nDemos cem generate supports documenting your elements\u0026rsquo; demos by linking directly from JSDoc, or by configurable file-system based discovery.\nJSDoc @demo Tag Add demos directly to your element class or members with the @demo tag:\n/** * @demo https://example.com/my-element-plain/ * @demo https://example.com/my-element-fancy/ - A fancier demo with description */ @customElement(\u0026#39;my-element\u0026#39;) class MyElement extends LitElement { // ... } Demos defined this way will always appear in your manifest for the element.\nAutomatic Demo Discovery cem can automatically discover demos from your codebase based on your repository structure and configuration. Demos that are co-located with their component\u0026rsquo;s source module will be prioritized in the generated manifest.\nDemo Discovery The urlPattern uses the standard URLPattern syntax with named parameters (:paramName). You can use it to match file paths and extract parameters to build your demo URLs.\nFor example, if your demos are in subdirectories like src/my-element/demos/foo.html, you could use a pattern like this:\nsourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: demoDiscovery: fileGlob: \u0026#34;src/**/demos/*.html\u0026#34; urlPattern: \u0026#34;/src/:tag/demos/:demo.html\u0026#34; urlTemplate: \u0026#34;https://example.com/elements/{{.tag | alias}}/{{.demo | slug}}/\u0026#34; URL Template Functions The urlTemplate supports Go template syntax with built-in functions:\nalias - Apply element alias mapping slug - Convert to URL-friendly format lower - Convert to lowercase upper - Convert to uppercase Use pipeline syntax ({{.param | function}}) or function calls ({{function .param}}).\nDemo discovery options:\nOption Type Description fileGlob string Glob pattern for discovering demo files. sourceControlRootUrl string Canonical public source control URL for your repository root (on the main branch). urlPattern string URLPattern with named parameters (:param) for matching demo file paths. urlTemplate string Go template with functions for generating canonical demo URLs. Monorepos If you are planning to use cem in an npm or yarn monorepo, the best way for now is to create a new .config/cem.yaml file for each package you want to generate for, instead of using a top-level config file.\nExample Root package.json:\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;npm run generate --workspaces\u0026#34; }, \u0026#34;workspaces\u0026#34;: [ \u0026#34;./core\u0026#34;, \u0026#34;./elements\u0026#34; ] } core/.config/cem.yaml:\ngenerate: files: - \u0026#39;./**/*.ts\u0026#39; core/package.json\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;cem generate\u0026#34; } } elements/.config/cem.yaml:\ngenerate: files: - \u0026#39;./**/*.ts\u0026#39; elements/package.json\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;cem generate\u0026#34; } } Usage Generate a custom elements manifest from your files:\ncem generate \\ \u0026#34;src/**/*.ts\u0026#34; \\ --design-tokens npm:@my-ds/tokens/tokens.json \\ --exclude \u0026#34;src/**/*.test.ts\u0026#34; \\ --output custom-elements.json For npm projects you can use npx @pwrs/cem generate ....\nThe generate command does not support remote packages. To inspect a remote package\u0026rsquo;s manifest, use the cem list command. Arguments Argument Type Description \u0026lt;files or globs\u0026gt; positional (array) Files or glob patterns to include --package, -p string Path to a package directory. --output, -o string Write the manifest to this file instead of stdout --watch, -w bool Watch files for changes and regenerate automatically --exclude, -e array Files or glob patterns to exclude --no-default-excludes bool Do not exclude files by default (e.g., .d.ts files will be included unless excluded explicitly) --design-tokens string Path or npm specifier for DTCG-format design tokens --design-tokens-prefix string CSS custom property prefix for design tokens --demo-discovery-file-glob string Glob pattern for discovering demo files --demo-discovery-url-pattern string URLPattern with named parameters for matching demo file paths --demo-discovery-url-template string Go template with functions for generating canonical demo URLs --source-control-root-url string Glob pattern for discovering demo files --project-dir string Deprecated: Use --package instead. By default, some files (like .d.ts TypeScript declaration files) are excluded from the manifest. Use --no-default-excludes if you want to include all matching files and manage excludes yourself.\n","link":"https://bennypowers.dev/cem/docs/commands/generate/","section":"docs","title":"Generate"},{"body":"The cem list command provides a fast, flexible way to inspect your custom elements manifest.\nWithout any subcommands, cem list prints a table of all declarations in the manifest.\ncem list Flags Flag Description --package, -p Deno-style package specifier (e.g., npm:@scope/package@^1.2.3) or path to a package directory. --format Set the output format. Can be table or tree. Default: table. --deprecated Only show deprecated items. Example:\ncem list --deprecated --format tree cem list --package npm:@vaadin/button@24.3.5 Subcommands tags Lists all custom element tag names in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Class, Module, Summary\nExample:\ncem list tags -c Class -c Module modules Lists all module paths in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Path\nExample:\ncem list modules attributes (aliases: attrs) Lists all attributes for a given custom element.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, DOM Property, Reflects, Summary\nExample:\ncem list attributes -t my-element -c \u0026#34;DOM Property\u0026#34; slots Lists all named and default slots for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list slots -t my-element events Lists all custom events fired by a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Type, Summary\nExample:\ncem list events -t my-element css-properties (aliases: css-props) Lists CSS custom properties for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Syntax, Default, Summary\nExample:\ncem list css-properties -t my-element css-states Lists CSS custom states for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-states -t my-element css-parts Lists CSS shadow parts for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-parts -t my-element methods Lists methods for a tag\u0026rsquo;s class.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Return, Privacy, Summary\nExample:\ncem list methods -t my-element demos Lists all demos for a given custom element.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: URL, Description\nExample:\ncem list demos -t my-element ","link":"https://bennypowers.dev/cem/docs/commands/list/","section":"docs","title":"List"},{"body":"The cem search command lets you search through the custom elements manifest for any element matching the given pattern.\nUsage cem search [pattern] [flags] Description The search command allows you to find any element in your custom elements manifest by searching through names, descriptions, summaries, and labels. This includes:\nCustom element tags Modules and files Attributes Slots CSS properties, parts, and states Events Methods and fields Functions and variables Demos The search pattern is treated as a regular expression by default, allowing for powerful and flexible searches. If the regex is invalid, it automatically falls back to literal string matching.\nAll searches are case-insensitive.\nOptions -f, --format string - Output format: table (default) or tree Examples Basic Search Search for anything containing \u0026ldquo;button\u0026rdquo;:\ncem search button Regular Expression Search Find elements starting with \u0026ldquo;my-\u0026rdquo; and ending with \u0026ldquo;button\u0026rdquo;:\ncem search \u0026#34;^my-.*button$\u0026#34; Find elements containing \u0026ldquo;click\u0026rdquo; OR \u0026ldquo;hover\u0026rdquo;:\ncem search \u0026#34;click|hover\u0026#34; Format Options Display results as a tree:\ncem search button --format tree Display results as a table (default):\ncem search button --format table Specific Content Types Find CSS-related properties:\ncem search \u0026#34;css.*property\u0026#34; Find header-related slots:\ncem search \u0026#34;slot.*header\u0026#34; Find deprecated items:\ncem search deprecated --format tree Output Formats Table Format (Default) The table format shows detailed information organized by sections:\n# \u0026lt;root\u0026gt; # module rh-button/rh-button.js # `\u0026lt;rh-button\u0026gt;` Triggers actions on the page or in the background ## Demos URL | Source -----------------------------------------------|-------- `https://ux.redhat.com/elements/button/demo/` | https://... ## CSS Parts Name -------- `button` Tree Format The tree format shows a hierarchical view of matching elements:\nSearch Results for: button \u0026lt;root\u0026gt; ├─┬ module rh-button/rh-button.js │ └─┬ \u0026lt;rh-button\u0026gt; │ └─┬ Parts │ └── button Regular Expression Features Since patterns are treated as regular expressions, you can use:\n^ - Start of string anchor $ - End of string anchor .* - Match any characters | - OR operator [abc] - Character class \\d, \\w, \\s - Character shortcuts If your regex is invalid, the search automatically falls back to literal string matching.\nGlobal Options The search command also supports all global cem options:\n-p, --package string - Package specifier or path --config string - Config file path -v, --verbose - Verbose output See Also cem list - List specific types of elements from the manifest cem validate - Validate manifest files cem generate - Generate manifest files ","link":"https://bennypowers.dev/cem/docs/commands/search/","section":"docs","title":"Search"},{"body":"","link":"https://bennypowers.dev/cem/tags/","section":"tags","title":"Tags"},{"body":"The cem validate command validates your custom-elements.json file against its corresponding JSON schema and provides intelligent warnings for potentially inappropriate manifest content.\ncem validate [path/to/custom-elements.json] By default, cem validate will look for a custom-elements.json file in the current directory. You can also provide a path to a different file.\nOptions --verbose, -v: Show detailed information including schema version --disable: Disable specific warning rules or categories (can be used multiple times) --format: Output format, either text (default) or json How it Works The validate command reads the schemaVersion field from your manifest and fetches the corresponding schema from https://unpkg.com/custom-elements-manifest@\u0026lt;version\u0026gt;/schema.json. Schemas are cached locally for performance.\nSchema Validation If the manifest is valid against the JSON schema, the command will exit with a 0 status code and print a success message. If the manifest is invalid, it will print detailed validation errors with contextual information and exit with a non-zero status code.\nIntelligent Warnings Beyond basic schema validation, cem validate analyzes your manifest for patterns that are technically valid but may indicate issues with your API documentation:\nLifecycle Methods Web Components lifecycle: connectedCallback, disconnectedCallback, attributeChangedCallback, adoptedCallback Lit Element lifecycle: firstUpdated, updated, willUpdate, getUpdateComplete, performUpdate, scheduleUpdate, requestUpdate, createRenderRoot Lit Element render method: render (only in Lit elements) Form-associated callbacks: formAssociatedCallback, formDisabledCallback, formResetCallback, formStateRestoreCallback Private Methods and Implementation Details Private methods: Methods starting with _ or # Static implementation fields: styles, shadowRootOptions, formAssociated, observedAttributes Internal utility methods: init, destroy, dispose, cleanup, debug, log Superclass Attribution Built-in types: Warns when built-in types like HTMLElement don\u0026rsquo;t have \u0026quot;module\u0026quot;: \u0026quot;global:\u0026quot; Verbose Content Large CSS defaults: CSS properties with very long default values Output Formats Text Format (Default) The default text format provides human-readable output with colors and formatting.\nJSON Format Use --format json to get machine-readable output suitable for CI/CD pipelines and tooling:\ncem validate --format json custom-elements.json JSON output structure:\n{ \u0026#34;valid\u0026#34;: true, \u0026#34;path\u0026#34;: \u0026#34;custom-elements.json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: \u0026#34;2.1.1\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;schema-required-property\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;my-element.js\u0026#34;, \u0026#34;declaration\u0026#34;: \u0026#34;class MyElement\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;required property \u0026#39;name\u0026#39; is missing\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;/modules/0/declarations/0\u0026#34; } ], \u0026#34;warnings\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;lifecycle-lit-render\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;my-element.js\u0026#34;, \u0026#34;declaration\u0026#34;: \u0026#34;class MyElement\u0026#34;, \u0026#34;member\u0026#34;: \u0026#34;method render\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;render method in Lit element should not be documented in public API\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;lifecycle\u0026#34; } ] } Configuration You can disable specific warning rules using configuration or command-line flags:\nConfiguration File # .cem.yaml warnings: disable: # Disable entire categories - lifecycle - private - implementation # Or disable specific rules - lifecycle-lit-render - implementation-static-styles - private-underscore-methods Command Line # Disable entire categories cem validate --disable lifecycle --disable private # Disable specific rules cem validate --disable lifecycle-lit-render --disable implementation-static-styles # Combine with JSON output cem validate --format json --disable lifecycle The --disable flag can be used multiple times and will be merged with any disabled rules from your configuration file.\nAvailable Warning Categories lifecycle - All lifecycle method warnings private - Private method warnings (underscore and hash prefixed) implementation - Implementation detail warnings (static fields) superclass - Superclass attribution warnings verbose - Verbose content warnings internal - Internal utility method warnings Specific Warning Rule IDs Lifecycle Rules lifecycle-web-components - Web Components lifecycle methods lifecycle-lit-methods - Lit Element lifecycle methods lifecycle-lit-render - Lit Element render method lifecycle-constructor - Constructor method lifecycle-form-callbacks - Form-associated element callbacks Private Method Rules private-underscore-methods - Methods starting with _ private-hash-methods - Methods starting with # Implementation Detail Rules implementation-static-styles - Static styles field implementation-shadow-root-options - shadowRootOptions field implementation-form-associated - formAssociated field implementation-observed-attributes - observedAttributes field Other Rules superclass-builtin-modules - Built-in superclass module attribution verbose-css-defaults - Large CSS property defaults internal-utility-methods - Internal utility methods Schema Validation Error IDs Schema validation errors also include unique IDs for programmatic handling:\nschema-required-property - Missing required property schema-additional-properties - Unexpected additional property schema-invalid-enum - Invalid enum value schema-invalid-kind - Invalid declaration kind schema-invalid-type - Wrong data type schema-invalid-format - Invalid format (e.g., URI, email) schema-invalid-pattern - String doesn\u0026rsquo;t match required pattern schema-value-too-small - Number below minimum schema-value-too-large - Number above maximum schema-string-too-short - String shorter than minLength schema-string-too-long - String longer than maxLength schema-array-too-short - Array shorter than minItems schema-array-too-long - Array longer than maxItems schema-duplicate-items - Array contains duplicate items schema-validation-error - Generic validation error ","link":"https://bennypowers.dev/cem/docs/commands/validate/","section":"docs","title":"Validate"}]