[{"body":"Number of runs per tool: 100 Number of files analyzed per run: 43 Benchmark results: lower is better (seconds) : 1.68 @lit-labs/cli 1.68 : 0.84 @custom-elements-manifest/analyzer 0.84 : 0.22 cem generate 0.22 @lit-labs/cli lit Docs 1.68s Avg Time 47.3KB Avg Output Size 100 Runs Run Breakdown: Time per Run (seconds) 1.64 1.66 1.69 1.71 1.73 1.75 1 100 Run # @custom-elements-manifest/analyzer cea Docs 0.84s Avg Time 59.2KB Avg Output Size 100 Runs Run Breakdown: Time per Run (seconds) 0.82 0.84 0.85 0.87 0.89 0.91 1 100 Run # cem generate cem Docs 0.22s Avg Time 46.3KB Avg Output Size 100 Runs Run Breakdown: Time per Run (seconds) 0.21 0.21 0.22 0.22 0.22 0.22 1 100 Run # ","link":"https://bennypowers.github.io/cem/benchmarks/","section":"","title":"Analyzer Benchmarks"},{"body":"","link":"https://bennypowers.github.io/cem/categories/","section":"categories","title":"Categories"},{"body":" Contributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm. Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nTesting Run Go tests:\nmake test Continuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\n","link":"https://bennypowers.github.io/cem/contributing/","section":"","title":"Contributing"},{"body":" cem cem is a command-line tool for generating and querying Custom Elements Manifest files. It can analyze your codebase and generate rich metadata for your custom elements, facilitating documentation, tooling, and integration. It can also query that manifest for information about your package\nInstallation npm install --save-dev @pwrs/cem For more options, see Installation docs\nFeatures cem generate Generates CEM files from source code using syntax analysis powered by go and tree-sitter. Identifies custom elements, classes, variables, functions, and exports. Supports elements written in idiomatic Lit typescript style, with a @customElement decorator, and @property decorators on class fields. [!NOTE] cem generate best supports LitElements written in idiomatic style with TypeScript decorators. There is rudimentary support for extends HTMLElement, but it is not a high priority for development. If you need something more specific open an issue.\nJSDoc Use JSDoc comments to add metadata to your element classes, similar to other tools. Add a description by separating the name of the item with -\n@attr / @attribute — Custom element attributes @csspart — CSS shadow parts @cssprop / @cssproperty — Custom CSS properties @cssstate — Custom CSS states @demo — Demo URL @deprecated — Marks a feature or member as deprecated @event — Custom events dispatched by the element @slot — Named or default slots @summary — Short summary for documentation See the test-fixtures directory for examples\nHTML Template Analysis for Slots and Parts Automatically detects \u0026lt;slot\u0026gt; elements and part attributes in your element’s render() template. Merges slot and part information found in templates with any provided via JSDoc, ensuring comprehensive documentation in the generated manifest. Deprecation and other metadata for slots and parts can be specified via YAML in HTML comments. Supports documenting slots and parts inline in your template HTML using HTML comments with YAML blocks. YAML comments are not necessary to detect slots and parts, but help in documenting them for your users. Examples \u0026lt;!-- summary: The main slot for content description: | This slot displays user-provided content. Supports multiline **markdown**. deprecated: true --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;!-- slot: summary: Named slot summary part: summary: Part summary --\u0026gt; \u0026lt;slot name=\u0026#34;info\u0026#34; part=\u0026#34;info-part\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; CSS Custom Properties Supports CSS Custom Properties by scanning css files and css tagged-template-literals\nCustom properties beginning with _ will be ignored (treated as \u0026ldquo;private\u0026rdquo;) e.g. var(--_private) If you provide a Design Tokens Community Group format module (JSON) to cem via the --design-tokens flag, cem will add metadata from your design system to any matching css variables it finds in your elements You can use jsdoc-like comment syntax before each var call to document your variables Example :host { color: /** * custom color for use in this element * @summary color * @deprecated just use the `color` property */ var(--custom-color); border: 1px solid /** Border color of the element */ var(--border-color); } Element Demos cem generate supports documenting your elements\u0026rsquo; demos by linking directly from JSDoc, or by configurable file-system based discovery.\n1. JSDoc @demo Tag Add demos directly to your element class or members with the @demo tag:\n/** * @demo https://example.com/my-element-plain/ * @demo https://example.com/my-element-fancy/ - A fancier demo with description */ @customElement(\u0026#39;my-element\u0026#39;) class MyElement extends LitElement { // ... } Demos defined this way will always appear in your manifest for the element.\n2. Demo Discovery cem can automatically discover demos from your codebase based on your repository structure and configuration.\nDemo Discovery Options Configure demo discovery with the demoDiscovery key in your .config/cem.yaml file\nsourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: demoDiscovery: fileGlob: \u0026#34;demos/**/*.html\u0026#34; urlPattern: \u0026#34;demos/(?P\u0026lt;tag\u0026gt;[\\w-]+)/(?P\u0026lt;demo\u0026gt;[\\w-]+).html\u0026#34; urlTemplate: \u0026#34;https://example.com/elements/{tag}/{demo}/\u0026#34; Demo discovery options:\nOption Type Description fileGlob string Glob pattern for discovering demo files. sourceControlRootUrl string Canonical public source control URL for your repository root (on the main branch). urlPattern string Pattern for generating demo URLs, e.g. \u0026quot;demos/{tag}.html\u0026quot;. {tag} is replaced by tag name. urlTemplate string (optional) Alternative URL template for demo links. Usage Generate a custom elements manifest from your files:\ncem generate \\ \u0026#34;src/**/*.ts\u0026#34; \\ --design-tokens npm:@my-ds/tokens/tokens.json \\ --exclude \u0026#34;src/**/*.test.ts\u0026#34; \\ --output custom-elements.json For npm projects you can use npx @pwrs/cem generate ....\nCommand Line Arguments Argument Type Description \u0026lt;files or globs\u0026gt; positional (array) Files or glob patterns to include --output, -o string Write the manifest to this file instead of stdout --exclude, -e array Files or glob patterns to exclude --no-default-excludes bool Do not exclude files by default (e.g., .d.ts files will be included unless excluded explicitly) --design-tokens, -t string Path or npm specifier for DTCG-format design tokens --design-tokens-prefix, -p string CSS custom property prefix for design tokens --demo-discovery-file-glob string Glob pattern for discovering demo files --demo-discovery-url-pattern string Go Regexp pattern with named capture groups for generating canonical demo urls --demo-discovery-url-template string URL pattern string using {groupName} syntax to interpolate named captures from the URL pattern --source-control-root-url string Glob pattern for discovering demo files --project-dir string Specify the project root directory to use for resolving relative paths and configuration. By default, some files (like .d.ts TypeScript declaration files) are excluded from the manifest. Use --no-default-excludes if you want to include all matching files and manage excludes yourself.\ncem list The cem list command provides a fast, flexible way to inspect custom elements, their features, and their metadata directly from your manifest file. With cem list, you can quickly explore and audit your custom elements API surface, making it easier to document, test, and share your components.\nAvailable Subcommands cem list — Lists all items in the custom elements manifest cem list tags — Lists all custom element tag names in the project. cem list modules — Lists all module paths in the project. cem list -t \u0026lt;tag\u0026gt; attrs — Lists all attributes for a given custom element tag. cem list -t \u0026lt;tag\u0026gt; slots — Lists all named and default slots for a tag. cem list -t \u0026lt;tag\u0026gt; events — Lists all custom events fired by a tag, including their types and descriptions. cem list -t \u0026lt;tag\u0026gt; css-properties — Lists CSS custom properties (CSS variables) for a tag. cem list -t \u0026lt;tag\u0026gt; css-states — Lists CSS custom states for a tag. cem list -t \u0026lt;tag\u0026gt; css-parts — Lists CSS shadow parts for a tag. cem list -t \u0026lt;tag\u0026gt; methods — Lists methods for a tag\u0026rsquo;s DOM object. Column Filtering and Output Use the --columns,-c flag to specify which columns to include in the output, e.g.:\ncem list events my-element -c name -c summary -c type cem list attrs my-element -c description --columns default Note that the name column is always included, and that if a column is specified but contains only empty values for all rows, it is automatically omitted from the output for clarity.\nOutput Formats Filters --deprecated Only show deprecated items. Works great with --format tree\nBy default, tables are shown in a human-readable table format. TODO: json, markdown, flat lists, etc Configuration Reference You can configure CEM via .config/cem.yaml, relative to your project root, or via CLI flags.\nExample Configuration sourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: files: - \u0026#34;src/**/*.ts\u0026#34; exclude: - \u0026#34;src/**/*.test.ts\u0026#34; output: \u0026#34;custom-elements.json\u0026#34; noDefaultExcludes: false designTokens: spec: \u0026#34;npm:@my-ds/tokens/tokens.json\u0026#34; prefix: \u0026#34;--my-ds\u0026#34; demoDiscovery: fileGlob: \u0026#34;demos/**/*.html\u0026#34; urlPattern: \u0026#34;demos/(?P\u0026lt;tag\u0026gt;[\\w-]+)/(?P\u0026lt;demo\u0026gt;[\\w-]+).html\u0026#34; urlTemplate: \u0026#34;https://example.com/elements/{tag}/{demo}/\u0026#34; Contributing For information on building and testing, please see CONTRIBUTING.md.\nLicense This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License v3.0.\n© 2025 Benny Powers web@bennypowers.com\n","link":"https://bennypowers.github.io/cem/","section":"","title":"Home"},{"body":"For go binaries:\ngo install bennypowers.dev/cem@latest For NPM projects:\nnpm install --save-dev @pwrs/cem Or clone this repository and build from source:\ngit clone https://github.com/bennypowers/cem.git cd cem make Shell Completion cem supports shell completion for Bash, Zsh, Fish, and PowerShell. The completion scripts provide tab completion for commands, flags, and file paths.\nBash To load completions in your current shell session:\nsource \u0026lt;(cem completion bash) To load completions for every new session, execute once:\nLinux:\ncem completion bash \u0026gt; /etc/bash_completion.d/cem macOS:\ncem completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/cem Zsh To load completions in your current shell session:\nsource \u0026lt;(cem completion zsh) To load completions for every new session, execute once:\ncem completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cem\u0026#34; You will need to start a new shell for this setup to take effect.\nFish To load completions in your current shell session:\ncem completion fish | source To load completions for every new session, execute once:\ncem completion fish \u0026gt; ~/.config/fish/completions/cem.fish PowerShell To load completions in your current shell session:\ncem completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your PowerShell profile.\n","link":"https://bennypowers.github.io/cem/installation/","section":"","title":"Installation"},{"body":"","link":"https://bennypowers.github.io/cem/tags/","section":"tags","title":"Tags"}]