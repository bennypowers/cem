[{"body":"The cem command-line tool has several commands to help you generate and query Custom Elements Manifests.\nGenerate Analyze your source code and automatically create a comprehensive custom-elements.json manifest file that documents all your custom elements and their APIs. Serve Start a development server with live reload, buildless TypeScript, and interactive demos. List Query and inspect your custom elements manifest with powerful filtering and display options to explore your component APIs interactively. Search Find elements, attributes, methods, and other API features across your entire project using flexible keyword and regex pattern matching. Validate Ensure your custom elements manifest files conform to the official schema and catch potential issues before publishing. ","link":"https://bennypowers.dev/cem/docs/reference/commands/","section":"docs","title":"Commands"},{"body":"This guide will walk you through creating your first custom element project with cem.\nPrerequisites Node.js 24+ or Go 1.24+ A code editor (VS Code, Neovim, etc.) Basic familiarity with custom elements / web components Quick Start Install cem - Get the tool installed Write your component with JSDoc documentation Generate the manifest: cem generate Create a demo HTML file Serve and test: cem serve The Development Workflow guide provides detailed examples and explanations for each step.\nEnhance Your Setup Use cem\u0026rsquo;s LSP and MCP servers to enhance your development environment.\nLSP Integration - Get autocomplete and validation in your editor MCP Integration - Enable AI assistant access to your components Choose Your Starting Point cem provides several example projects to help you get started. Choose based on your needs:\nminimal example with just a single, simple element, intermediate example with multiple elements \u0026amp; demos, \u0026ldquo;kitchen sink\u0026rdquo; example with automatic design token discovery, demos, etc. See the full Examples Overview for all options.\nThe Development Workflow cem uses a manifest-driven workflow: Write → Generate → Serve → Test → Edit. You write custom elements with JSDoc documentation, generate a manifest file, and use the dev server to view and test your components with live reload. The manifest powers LSP features in your editor and enables the dev server\u0026rsquo;s automatic documentation and interactive controls.\nFor a complete walkthrough of each phase, see the Development Workflow guide.\nFeatures The dev server provides:\nLive Reload - Changes automatically refresh your browser Buildless Development - Write TypeScript and import CSS without build steps Import Maps - Use npm packages without bundling Interactive Knobs - Automatically generated controls for testing component variations Error Overlay - Developer-friendly error messages with source maps Rendering Modes - Test in light DOM, shadow DOM, or chromeless mode Next Steps Reference Documentation Commands - CLI command reference Configuration - Complete config options Serve Command - Dev server options Need help? See Troubleshooting for common issues and solutions.\n","link":"https://bennypowers.dev/cem/docs/usage/getting-started/","section":"docs","title":"Getting Started"},{"body":"Install CEM and verify your installation.\nInstallation Methods NPM Projects For Node.js-based projects, install CEM as a development dependency:\nnpm install --save-dev @pwrs/cem Or with pnpm:\npnpm add -D @pwrs/cem Go Binary Install the latest version directly with Go:\ngo install bennypowers.dev/cem@latest This installs the cem binary to your $GOPATH/bin directory.\nBuild from Source Clone the repository and build locally:\ngit clone https://github.com/bennypowers/cem.git cd cem make The compiled binary will be available in the dist/ directory. To install it in ~/.local/bin, run:\nmake install Verify Installation After installation, verify CEM is working:\ncem version You should see the version number printed to your terminal.\nShell Completion CEM supports shell completion for Bash, Zsh, Fish, and PowerShell. The completion scripts provide tab completion for commands, flags, and file paths.\nBash To load completions in your current shell session:\nsource \u0026lt;(cem completion bash) To load completions for every new session, execute once:\nLinux:\ncem completion bash \u0026gt; /etc/bash_completion.d/cem macOS:\ncem completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/cem Zsh To load completions in your current shell session:\nsource \u0026lt;(cem completion zsh) To load completions for every new session, execute once:\ncem completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cem\u0026#34; You will need to start a new shell for this setup to take effect.\nFish To load completions in your current shell session:\ncem completion fish | source To load completions for every new session, execute once:\ncem completion fish \u0026gt; ~/.config/fish/completions/cem.fish PowerShell To load completions in your current shell session:\ncem completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your PowerShell profile.\nNext Steps After installation, set up CEM for your development environment:\nLSP Integration - Configure language server features in your editor MCP Integration - Set up AI assistant integration Getting Started - Create your first project ","link":"https://bennypowers.dev/cem/docs/installation/","section":"docs","title":"Installation"},{"body":" TL;DR: Create .config/cem.yaml to configure file patterns, output paths, and dev server options. Most users only need generate.files and generate.output. See the complete example below for all options. You can configure cem via a cem.yaml file in your project\u0026rsquo;s .config directory, or by using command-line flags.\nConfiguration File Here is a complete example of a .config/cem.yaml file with all available options explained.\n# The canonical public source control URL for your repository root. # Used for generating source links in the manifest. sourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; # Additional packages to load for MCP and LSP. # Accepts URLs, npm:, or jsr: specifiers. additionalPackages: - \u0026#34;https://cdn.jsdelivr.net/npm/@example/components/\u0026#34; - \u0026#34;npm:@vaadin/button@24.3.5\u0026#34; - \u0026#34;jsr:@example/elements\u0026#34; # Configuration for the `generate` command. generate: # A list of glob patterns for files to include in the analysis. files: - \u0026#34;src/**/*.ts\u0026#34; # A list of glob patterns for files to exclude from the analysis. exclude: - \u0026#34;src/**/*.test.ts\u0026#34; # The path to write the final custom-elements.json manifest. # If omitted, the manifest is written to standard output. output: \u0026#34;custom-elements.json\u0026#34; # By default, certain files like TypeScript declaration files (`.d.ts`) are excluded. # Set to `true` to include all files matched by the `files` glob. noDefaultExcludes: false # Configuration for integrating Design Tokens. designTokens: # An npm specifier or local path to a DTCG-formatted JSON module. spec: \u0026#34;npm:@my-ds/tokens/tokens.json\u0026#34; # A CSS custom property prefix to apply to the design tokens. prefix: \u0026#34;--my-ds\u0026#34; # Configuration for discovering element demos. demoDiscovery: # A glob pattern to find demo files. fileGlob: \u0026#34;src/**/demos/*.html\u0026#34; # URLPattern for extracting parameters from demo file paths. # Uses standard URLPattern syntax with named parameters. urlPattern: \u0026#34;/src/:component/demos/:demo.html\u0026#34; # Go template to construct the canonical URL for a demo. # Uses {{.param}} syntax with optional template functions. # Available functions: alias, slug, lower, upper urlTemplate: \u0026#34;https://example.com/components/{{.component | alias}}/demo/{{.demo | slug}}/\u0026#34; # Configuration for validation warnings. warnings: disable: # Disable entire categories - \u0026#34;lifecycle\u0026#34; - \u0026#34;private\u0026#34; # Or disable specific warning rules - \u0026#34;lifecycle-lit-render\u0026#34; - \u0026#34;implementation-static-styles\u0026#34; # Configuration for the `serve` command. serve: # Port to listen on port: 8000 # Disable live reload no-reload: false # Glob patterns to ignore in file watcher watchIgnore: - \u0026#39;dist/**\u0026#39; - \u0026#39;_site/**\u0026#39; - \u0026#39;node_modules/**\u0026#39; # Demo rendering configuration demos: # Default rendering mode for demos: \u0026#34;light\u0026#34; (default), \u0026#34;shadow\u0026#34;, or \u0026#34;iframe\u0026#34; # Can be overridden per-demo with ?rendering=shadow|light query parameter # Note: \u0026#34;iframe\u0026#34; mode is not yet implemented rendering: light # URL rewrites for src/dist separation # Rewrites request URLs to source file paths for TypeScript resolution # Automatically detected from tsconfig.json (rootDir/outDir) # Manual rewrites override automatic detection urlRewrites: - urlPattern: \u0026#34;/dist/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; - urlPattern: \u0026#34;/lib/:path*\u0026#34; urlTemplate: \u0026#34;/sources/{{.path}}\u0026#34; # Import map configuration importMap: # Enable automatic import map generation (default: true) generate: true # Path to a JSON file containing custom import map entries # These entries are merged with auto-generated imports overrideFile: \u0026#39;.config/importmap.json\u0026#39; # Import map override from config (highest priority) # Full import map structure with imports and scopes override: imports: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/+esm\u0026#39; \u0026#39;lit/\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/\u0026#39; scopes: \u0026#39;/demos/\u0026#39;: \u0026#39;lit\u0026#39;: \u0026#39;/node_modules/lit/index.js\u0026#39; # Transform configuration transforms: # TypeScript transformation typescript: enabled: true target: es2022 # es2015, es2016, es2017, es2018, es2019, es2020, es2021, es2022, es2023, esnext # CSS transformation (opt-in) css: enabled: true # Glob patterns for CSS files to transform to JavaScript modules include: - \u0026#39;src/**/*.css\u0026#39; - \u0026#39;elements/**/*.css\u0026#39; # Glob patterns to exclude from transformation exclude: - \u0026#39;demo/**/*.css\u0026#39; - \u0026#39;**/*.min.css\u0026#39; Import Map Overrides The dev server automatically generates import maps from package.json, but you can customize or override these mappings.\nOverride Priority Import map entries are merged with the following priority (highest wins):\nAuto-generated - From package.json dependencies Override file - Custom import map JSON file (via serve.importMap.overrideFile) Config overrides - Individual overrides in config (via serve.importMap.override) Override File Create a JSON file with custom import map entries:\n.config/importmap.json:\n{ \u0026#34;imports\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;https://cdn.jsdelivr.net/npm/lit@3/+esm\u0026#34;, \u0026#34;lit/\u0026#34;: \u0026#34;https://cdn.jsdelivr.net/npm/lit@3/\u0026#34;, \u0026#34;@patternfly/elements/\u0026#34;: \u0026#34;/node_modules/@patternfly/elements/\u0026#34; }, \u0026#34;scopes\u0026#34;: { \u0026#34;/demos/\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;/node_modules/lit/index.js\u0026#34; } } } Then reference it in your config:\nserve: importMap: overrideFile: \u0026#39;.config/importmap.json\u0026#39; Config Overrides Specify overrides directly in your config using the full import map structure:\nserve: importMap: override: imports: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/+esm\u0026#39; \u0026#39;lit/\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/\u0026#39; \u0026#39;@custom/library\u0026#39;: \u0026#39;/vendor/custom-library.js\u0026#39; scopes: \u0026#39;/demos/legacy/\u0026#39;: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@2/+esm\u0026#39; Config overrides support both imports and scopes, giving you full control over the import map structure.\nUse Cases Use CDN instead of local modules:\nserve: importMap: override: imports: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/+esm\u0026#39; \u0026#39;lit/\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/\u0026#39; Point to local development version:\nserve: importMap: override: imports: \u0026#39;@my-org/components\u0026#39;: \u0026#39;/packages/components/src/index.js\u0026#39; Override specific subpaths:\nserve: importMap: override: imports: \u0026#39;some-lib/broken-export\u0026#39;: \u0026#39;/local-fixes/fixed-export.js\u0026#39; Use scoped overrides for different contexts:\nserve: importMap: override: imports: \u0026#39;react\u0026#39;: \u0026#39;https://esm.sh/react@18\u0026#39; scopes: \u0026#39;/demos/legacy/\u0026#39;: \u0026#39;react\u0026#39;: \u0026#39;https://esm.sh/react@17\u0026#39; Disable automatic generation (use only override file):\nserve: importMap: generate: false overrideFile: \u0026#39;.config/importmap.json\u0026#39; URL Rewrites URL rewrites enable buildless TypeScript development with src/dist separation. The dev server automatically resolves requests to compiled output paths (e.g., /dist/foo.js) to their TypeScript source files (e.g., /src/foo.ts).\nAutomatic Detection from tsconfig.json The dev server automatically reads your tsconfig.json and creates URL rewrites based on rootDir and outDir:\ntsconfig.json:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34; } } This automatically creates the rewrite:\nserve: urlRewrites: - urlPattern: \u0026#34;/dist/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; How it works:\nRequest arrives: GET /dist/components/button.js Dev server matches URL pattern: /dist/:path* captures path=components/button.js Applies URL template: /src/{{.path}} → /src/components/button.js Resolves to source file: /src/components/button.ts Transforms TypeScript to JavaScript on-demand Serves transformed code with source maps Manual Configuration Override or extend automatic rewrites in your config:\nserve: urlRewrites: - urlPattern: \u0026#34;/dist/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; - urlPattern: \u0026#34;/lib/:path*\u0026#34; urlTemplate: \u0026#34;/sources/{{.path}}\u0026#34; - urlPattern: \u0026#34;/build/:path*\u0026#34; urlTemplate: \u0026#34;/typescript/{{.path}}\u0026#34; Manual rewrites take precedence over automatic detection from tsconfig.json. URL patterns use dynamic segments (:path*, :name) and templates use Go template syntax ({{.path}}).\nResolution Strategy The dev server uses a multi-strategy approach to find source files:\nCo-located files (backward compatibility)\nTries /dist/button.ts alongside /dist/button.js Supports in-place compilation workflows URL rewrites (src/dist separation)\nMatches URL pattern: /dist/:path* Applies template: /src/{{.path}} Resolves /dist/button.js to /src/button.ts If neither strategy finds a source file, the request falls through to static file serving.\ntsconfig.json Inheritance URL rewrites work with TypeScript\u0026rsquo;s extends feature:\ntsconfig.base.json:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34; } } tsconfig.json:\n{ \u0026#34;extends\u0026#34;: \u0026#34;./tsconfig.base.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34; } } The dev server correctly merges inherited values and creates the rewrite pattern \u0026quot;/dist/:path*\u0026quot; → \u0026quot;/src/{{.path}}\u0026quot;.\nWorkspace Mode In workspace/monorepo setups, each package can have its own tsconfig.json with different URL rewrites:\npackages/ components/ tsconfig.json # rootDir: \u0026#34;src\u0026#34;, outDir: \u0026#34;dist\u0026#34; src/ dist/ elements/ tsconfig.json # rootDir: \u0026#34;lib\u0026#34;, outDir: \u0026#34;build\u0026#34; lib/ build/ Each package\u0026rsquo;s rewrites are discovered independently and applied to requests within that package\u0026rsquo;s path.\nEdge Cases Default rootDir with custom outDir:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;rootDir\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;dist\u0026#34; } } Creates rewrite: \u0026quot;/dist/:path*\u0026quot; → \u0026quot;/./{{.path}}\u0026quot;\nThe dev server normalizes this correctly via filepath.Join(), resolving /dist/foo.js to /foo.ts at the project root.\nSame rootDir and outDir:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;rootDir\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;.\u0026#34; } } No URL rewrite is created (in-place compilation). The dev server falls back to co-located file resolution.\nUse Cases Standard src/dist separation:\n# Automatic from tsconfig.json # No config needed - just works! Custom build output directories:\nserve: urlRewrites: - urlPattern: \u0026#34;/lib/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; - urlPattern: \u0026#34;/esm/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; - urlPattern: \u0026#34;/cjs/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; Legacy projects with non-standard structure:\nserve: urlRewrites: - urlPattern: \u0026#34;/compiled/:path*\u0026#34; urlTemplate: \u0026#34;/source/typescript/{{.path}}\u0026#34; - urlPattern: \u0026#34;/js/:path*\u0026#34; urlTemplate: \u0026#34;/ts/{{.path}}\u0026#34; Debugging URL Rewrites Use verbose logging to see path resolution in action:\ncem serve --verbose Look for log messages like:\nPathResolver: mapped source found: /dist/button.js -\u0026gt; /src/button.ts (pattern: /dist/:path* -\u0026gt; /src/{{.path}}) Demo Discovery Features The demo discovery system supports multiple ways to control how demos are associated with elements and how their URLs are generated.\nHTML5 Microdata Demos can use HTML5 microdata to explicitly declare their URLs and associations:\n\u0026lt;!-- Explicit URL declaration --\u0026gt; \u0026lt;meta itemprop=\u0026#34;demo-url\u0026#34; content=\u0026#34;/elements/call-to-action/demo/\u0026#34;\u0026gt; \u0026lt;meta itemprop=\u0026#34;description\u0026#34; content=\u0026#34;Primary variant demonstration\u0026#34;\u0026gt; \u0026lt;!-- Rich markdown description --\u0026gt; \u0026lt;script type=\u0026#34;text/markdown\u0026#34; itemprop=\u0026#34;description\u0026#34;\u0026gt; # Call to Action Demo Showcases primary variant with styling, accessibility, and interaction states. \u0026lt;/script\u0026gt; \u0026lt;!-- Explicit element association --\u0026gt; \u0026lt;meta itemprop=\u0026#34;demo-for\u0026#34; content=\u0026#34;rh-button pf-button\u0026#34;\u0026gt; Association Priority The system uses the following priority order to associate demos with elements:\nExplicit microdata: \u0026lt;meta itemprop=\u0026quot;demo-for\u0026quot; content=\u0026quot;element-name\u0026quot;\u0026gt; Path-based (only when urlPattern is configured): Elements whose tag names appear in demo file paths Content-based: Custom elements found in the demo HTML Note: Path-based association is disabled when urlPattern is not configured. In that case, the system uses only explicit microdata (priority 1) and content-based discovery (priority 3).\nPath-Based Association with URLPattern When a urlPattern is configured, the system extracts parameter values from demo file paths and looks up matching elements by tag name. Important: The system matches extracted parameter values against element tag names directly, not aliases.\nExample Configuration:\ndemoDiscovery: fileGlob: \u0026#34;shop/**/demos/*.html\u0026#34; urlPattern: \u0026#34;/shop/:element/:demo.html\u0026#34; urlTemplate: \u0026#34;https://mysite.com/shop/{{.element | alias}}/{{.demo}}/\u0026#34; Elements in manifest:\n# Element tag names - my-shop-button - my-accordion - my-accordion-header Path Matching Behavior:\n✅ /shop/my-shop-button/basic.html → matches my-shop-button (tag name in :element position) ❌ /shop/shop-button/basic.html → no match (looks for element with tag name \u0026ldquo;shop-button\u0026rdquo;) ✅ /shop/my-accordion-header/demo.html → matches my-accordion-header only ❌ /shop/my-accordion-header/demo.html → does NOT match my-accordion (exact match required) Note on URL Generation: While the urlTemplate uses {{.element | alias}} to transform tag names into aliases for generated URLs (e.g., my-shop-button → shop-button), the reverse transformation (alias → tag name) is not performed during path-based demo association. Always use tag names in file paths for path-based matching to work correctly.\nDescription Sources Demo descriptions are extracted exclusively from microdata:\nMeta tags: \u0026lt;meta itemprop=\u0026quot;description\u0026quot; content=\u0026quot;Simple description\u0026quot;\u0026gt; Script tags: \u0026lt;script type=\u0026quot;text/markdown\u0026quot; itemprop=\u0026quot;description\u0026quot;\u0026gt;Rich **markdown** content\u0026lt;/script\u0026gt; URL Generation Priority URLs are generated using the following priority:\nExplicit microdata: \u0026lt;meta itemprop=\u0026quot;demo-url\u0026quot; content=\u0026quot;/path/to/demo/\u0026quot;\u0026gt; URLPattern fallback: Using urlPattern and urlTemplate configuration No URL: Demo is skipped if no pattern matches URL Template Functions The urlTemplate uses Go template syntax with a set of built-in functions for transforming URLPattern parameters:\nFunction Description Example alias Apply element alias mapping from configuration {{.tag | alias}} slug Convert to URL-friendly slug format {{.demo | slug}} lower Convert to lowercase {{.component | lower}} upper Convert to uppercase {{.section | upper}} Template Examples:\n# Basic parameter interpolation urlTemplate: \u0026#34;https://example.com/{{.component}}/{{.demo}}/\u0026#34; # Apply alias transformation urlTemplate: \u0026#34;https://example.com/{{.component | alias}}/{{.demo}}/\u0026#34; # Chain multiple functions urlTemplate: \u0026#34;https://example.com/{{.component | alias | slug}}/{{.demo | lower}}/\u0026#34; # Function call syntax (alternative) urlTemplate: \u0026#34;https://example.com/{{alias .component}}/{{slug .demo}}/\u0026#34; Important: All transformations must be explicitly specified. Unlike previous versions, no automatic aliasing or slugification is applied unless explicitly requested in the template.\nConfiguration Examples Minimal (microdata-driven):\ndemoDiscovery: fileGlob: elements/**/demo/*.html URLPattern with explicit configuration:\ndemoDiscovery: fileGlob: elements/**/demo/*.html urlPattern: \u0026#34;/elements/:element/demo/:demo.html\u0026#34; urlTemplate: \u0026#34;https://site.com/components/{{.element | alias}}/demo/{{.demo | slug}}/\u0026#34; Complex multi-site example:\ndemoDiscovery: fileGlob: src/components/**/demos/*.html urlPattern: \u0026#34;/src/components/:component/demos/:variant.html\u0026#34; urlTemplate: \u0026#34;https://{{.component | alias | lower}}.examples.com/{{.variant | slug}}/\u0026#34; Global Flags These flags can be used with any cem command.\nFlag Description --config Path to a custom config file. --package Package specifier: npm:@scope/package, URL (https://cdn.example.com/pkg/), or local path. --verbose, -v Enable verbose logging output. --help, -h Show help for a command. Package Specifier Examples # Local project directory cem list -p ./my-components # npm package (fetched from CDN) cem list -p npm:@rhds/elements@2.0.0 # Direct URL to package root cem list -p https://cdn.jsdelivr.net/npm/@shortfuse/materialdesignweb/ # jsr package cem list -p jsr:@example/elements Command-Line Flags All configuration options can also be set via command-line flags. Flags will always override any values set in the configuration file.\nFor example, to override the output and exclude options for the generate command:\ncem generate --output my-manifest.json --exclude \u0026#34;src/legacy/**\u0026#34; Validate Command Flags The validate command supports additional flags:\nFlag Description --disable Disable specific warning rules or categories (repeatable). --format Output format: text (default) or json. For example, to validate with disabled warnings and JSON output:\ncem validate --disable lifecycle --disable private --format json ","link":"https://bennypowers.dev/cem/docs/reference/configuration/","section":"docs","title":"Configuration"},{"body":" TL;DR: The workflow is Write → Generate → Serve → Test → Edit. Write components with JSDoc, run cem generate when APIs change, use cem serve for live development. Skip regenerating for styling/implementation tweaks. cem uses a manifest-driven development approach where you write custom elements with JSDoc documentation, generate a JSON manifest from your source code, and use that manifest to power developer tooling. The manifest enables LSP features like autocomplete and validation in your editor, provides AI assistants with component information through MCP , and drives the dev server\u0026rsquo;s automatic documentation and interactive controls . This means your documentation isn\u0026rsquo;t just comments—it becomes the foundation for your entire development experience.\nThe workflow follows a continuous cycle: write components with JSDoc, generate the manifest to capture their APIs, serve them with hot reload for rapid iteration, test with interactive knobs and manual validation, then edit based on feedback. For quick styling or implementation tweaks you can skip regenerating the manifest, but when you change public APIs (properties, slots, events, CSS parts) you\u0026rsquo;ll regenerate to keep tooling in sync. The dev server provides buildless TypeScript transformation , automatic import maps from package.json, and live reload, making the edit-test loop nearly instantaneous.\nThe Core Cycle cem follows a manifest-driven development workflow with five key phases:\ngraph LR A[Write] --\u003e B[Generate] B --\u003e C[Serve] C --\u003e D[Test] D --\u003e E[Edit] E --\u003e A 1. Write Create your custom element with JSDoc documentation:\nimport { LitElement, html, css } from \u0026#39;lit\u0026#39;; import { customElement, property } from \u0026#39;lit/decorators.js\u0026#39;; /** * Displays a personalized greeting message * * @summary A simple greeting component */ @customElement(\u0026#39;hello-world\u0026#39;) export class HelloWorld extends LitElement { static styles = css` :host { display: block; font-family: sans-serif; } #greeting { /** Text color (default: currentColor) */ color: var(--greeting-color, currentColor); padding: 1rem; } `; /** * The name to greet */ @property() name = \u0026#39;World\u0026#39;; render() { return html` \u0026lt;!-- The greeting text container --\u0026gt; \u0026lt;div id=\u0026#34;greeting\u0026#34; part=\u0026#34;greeting\u0026#34;\u0026gt; Hello, ${this.name}! \u0026lt;!-- Default slot for custom content --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `; } } Use JSDoc to document all public APIs: attributes, properties, slots, events, CSS parts, and CSS custom properties. See Documenting Components for complete JSDoc tag reference and examples.\n2. Generate Run cem generate to create or update your manifest:\ncem generate This analyzes your code and produces custom-elements.json with metadata about your components. Regenerate after adding new components or changing public APIs (properties, attributes, slots, events, CSS APIs), and before committing to keep the manifest in sync. For quick styling or implementation tweaks during development, you can skip regeneration since cem serve works without it.\nThe manifest powers LSP features like autocomplete and validation, enables MCP integration for AI assistants, drives the dev server\u0026rsquo;s component listing, and supports documentation generation.\n3. Serve Start the development server:\ncem serve The server runs at http://localhost:8000 by default and automatically opens your browser to the element listing page. It provides:\nComponent listing - Browse all elements discovered from your manifest Live demos - See components in action with interactive controls Hot reload - Automatic refresh when source files change Buildless TypeScript - Import .ts files directly without compilation Import maps - Use npm packages without bundling The server watches your source files and automatically reloads the browser when changes are detected. For implementation tweaks and styling changes, you\u0026rsquo;ll see updates immediately without regenerating the manifest.\nCommon dev server options:\n# Use a different port cem serve --port 3000 # Start in chromeless mode for testing cem serve --rendering=chromeless # Disable live reload cem serve --no-reload See Serve Command Reference for all available options.\n4. Test Interact with your components in the browser by trying different property values, testing user interactions like clicks and typing, verifying responsive behavior, checking accessibility with screen readers, and testing across browsers. Use interactive knobs to tweak element attributes and properties in real-time.\n5. Edit Based on testing, make changes to your component. Quick fixes like styling changes, implementation details, internal logic, and performance optimizations don\u0026rsquo;t need a manifest update. API changes—adding properties, attributes, slots, events, or CSS APIs, changing types or defaults, or updating documentation—require regenerating the manifest:\ncem generate The dev server will detect the change and reload automatically.\nIntegration Points LSP Integration The Language Server Protocol uses your manifest to provide autocomplete when using elements in HTML, hover documentation for attributes, validation of slot names and attribute values, and go-to-definition from usage to source. See LSP Integration for setup.\nMCP Integration The Model Context Protocol gives AI assistants access to your components, allowing them to understand component APIs, generate correct HTML with proper slots, suggest appropriate attribute values, and validate component usage. See MCP Integration for setup.\nCI/CD Integration Automate manifest generation in your build pipeline:\n# GitHub Actions example - name: Generate manifest run: | npm run analyze # or: cem generate git diff --exit-code custom-elements.json This ensures the manifest stays in sync with code changes.\nBest Practices Documentation-First Development Write JSDoc before implementing features:\nDocument the API - Define properties, slots, events Generate manifest - See how it looks Implement - Write the component code Test - Verify behavior matches documentation This ensures documentation drives implementation, not the other way around.\nIncremental Regeneration You don\u0026rsquo;t need to regenerate the manifest after every change:\nSkip regeneration when tweaking styles, fixing implementation bugs, refactoring internal code, or adding private methods. Regenerate for public API changes, documentation updates, before committing, and before publishing.\nThe --watch flag can help during active development:\ncem generate --watch you don\u0026rsquo;t need to run cem generate --watch alongside the dev server, it rebuilds the manifest itself in-memory when your sources change. Demo-Driven Development Create demos as you build:\nStart with demo - Write the HTML you want to work Implement component - Make the demo functional Refine demo - Add edge cases and variations Document patterns - Add descriptions and guidance Demos become living documentation and test cases.\nWorkspace Organization Structure your project with our recommended layout for efficient workflows:\nmy-components/ ├── elements/ │ ├── hello-world/ │ │ ├── hello-world.ts # Component │ │ ├── hello-world.css # Styles │ │ └── demo/ │ │ ├── basic.html # Basic demo │ │ └── variants.html # Variations │ └── my-card/ │ ├── my-card.ts │ └── demo/ │ └── index.html ├── .config/ │ └── cem.yaml # `cem` configuration ├── custom-elements.json # Generated manifest └── package.json This structure keeps components self-contained, co-locates demos with components, makes navigation easy, and works well with monorepos.\nCommon Workflows Adding a New Component # 1. Create component file mkdir -p elements/my-button/demo/ touch elements/my-button/my-button.ts # 2. Write component with JSDoc # 3. Generate manifest cem generate # 4. Create demo touch elements/my-button/demo/index.html # 5. Start dev server cem serve # 6. Test and iterate Updating Component APIs # 1. Update JSDoc and code # 2. Regenerate manifest cem generate # 3. Verify in dev server (refreshes automatically) # Already running: cem serve # 4. Update demos if needed # 5. Test changes Publishing Components # 1. Ensure manifest is current cem generate # 2. Run tests npm test # 3. Build if needed npm run build # 4. Publish npm publish The manifest is included in your package and enables LSP/MCP for consumers.\nSee Also Getting Started - First project walkthrough Documenting Components - JSDoc usage guide and examples Examples Overview - Starter project templates Working with Demos - Demo organization strategies Buildless Development - TypeScript without builds Using LSP Features - Editor integration tips Troubleshooting - Common issues and solutions ","link":"https://bennypowers.dev/cem/docs/usage/workflow/","section":"docs","title":"Development Workflow"},{"body":" TL;DR: Install CEM, then configure your editor to run cem lsp. VS Code users can install the extension. Neovim/Zed users configure their LSP client to start cem lsp for HTML/TypeScript files. Configure the CEM Language Server Protocol integration for your editor to get intelligent autocomplete, hover documentation, and validation for custom elements.\nPrerequisites Install CEM first if you haven\u0026rsquo;t already.\nWhat is LSP? The Language Server Protocol provides a standard way to add language-specific features to any editor. The CEM language server analyzes your custom elements manifests to offer contextual autocomplete, hover documentation, go-to-definition, and other IDE enhancements for HTML and TypeScript files.\nFeatures All editors with LSP support get the same core features:\n✅ Autocomplete - Tag names, attributes, slot names, and values ✅ Hover Documentation - Element and attribute documentation on hover ✅ Go-to-Definition - Jump to element source code ✅ Go-to-References - Find all usages of elements across your workspace ✅ Validation - Real-time error detection for slots, attributes, and tag names ✅ Quick Fixes - One-click typo corrections and import suggestions ✅ Workspace Symbols - Search and navigate elements project-wide See Using LSP Features for detailed usage guides.\nEditor Configuration Neovim For Neovim 0.12+\u0026rsquo;s native LSP configuration support, create ~/.config/nvim/lsp/cem.lua:\n---https://bennypowers.dev/cem/ --- ---`cem lsp` provides editor features for custom-elements a.k.a. web components --- ---Install with go ---```sh ---go install bennypowers.dev/cem ---``` ---Or with NPM ---```sh ---npm install -g @pwrs/cem ---``` --- ---@type vim.lsp.ClientConfig return { cmd = { \u0026#39;cem\u0026#39;, \u0026#39;lsp\u0026#39; }, root_markers = { \u0026#39;custom-elements.json\u0026#39;, \u0026#39;package.json\u0026#39;, \u0026#39;.git\u0026#39; }, filetypes = { \u0026#39;html\u0026#39;, \u0026#39;typescript\u0026#39;, \u0026#39;javascript\u0026#39; }, -- Control debug logging via LSP trace levels trace = \u0026#39;off\u0026#39;, -- \u0026#39;off\u0026#39; | \u0026#39;messages\u0026#39; | \u0026#39;verbose\u0026#39; } VS Code Install the Custom Elements Language Server extension from the VS Code marketplace. The extension bundles the language server and provides configuration options.\nConfiguration options in settings.json:\n{ \u0026#34;cem.lsp.executable\u0026#34;: \u0026#34;\u0026#34;, // Custom path (empty = use bundled) \u0026#34;cem.lsp.trace.server\u0026#34;: \u0026#34;off\u0026#34; // LSP trace level: \u0026#34;off\u0026#34; | \u0026#34;messages\u0026#34; | \u0026#34;verbose\u0026#34; } Emacs Depending on which LSP plugin you use, configure Emacs to run cem for HTML, JavaScript, and TypeScript files:\nlsp-mode:\n(lsp-register-client (make-lsp-client :new-connection (lsp-stdio-connection \u0026#39;(\u0026#34;cem\u0026#34; \u0026#34;lsp\u0026#34;)) :major-modes \u0026#39;(html-mode typescript-mode js-mode) :server-id \u0026#39;cem-lsp)) eglot:\n(add-to-list \u0026#39;eglot-server-programs \u0026#39;((html-mode typescript-mode js-mode) . (\u0026#34;cem\u0026#34; \u0026#34;lsp\u0026#34;))) Claude Code Install CEM first if not already installed:\nnpm install -g @pwrs/cem # or go install bennypowers.dev/cem@latest Then install the plugin:\n/plugin marketplace add bennypowers/cem /plugin install cem The LSP activates automatically for HTML, TypeScript, and JavaScript files.\nBonus: The plugin also includes MCP server support. See MCP Integration for details.\nOther Editors Configure your LSP client to run cem lsp for file types html, typescript, and javascript. The server communicates over stdio and follows the standard LSP specification.\nTypical configuration elements:\nCommand: cem lsp File types: html, typescript, javascript Root markers: custom-elements.json, package.json, .git Transport: stdio Verify Installation After configuring your editor:\nOpen an HTML file in your project Start typing a custom element tag name You should see autocomplete suggestions for your custom elements If autocomplete doesn\u0026rsquo;t appear:\nEnsure you have a custom-elements.json in your project (run cem generate) Check your editor\u0026rsquo;s LSP logs for errors Try enabling verbose logging (see configuration section) Debug Logging Debug logging is controlled via the LSP standard $/setTrace notification. Most editors expose this through trace level settings:\n\u0026quot;off\u0026quot; - No debug logging (default) \u0026quot;messages\u0026quot; - Basic debug logging \u0026quot;verbose\u0026quot; - Detailed debug logging Consult your editor\u0026rsquo;s LSP plugin documentation for how to set trace levels.\nNext Steps Using LSP Features - Learn how to use autocomplete, hover, and validation LSP Protocol Reference - Technical API details Getting Started - Create your first project ","link":"https://bennypowers.dev/cem/docs/installation/lsp/","section":"docs","title":"LSP Integration"},{"body":"The cem serve command starts a development server for custom element development with live reload, TypeScript transformation, and automatic import map generation.\ncem serve [flags] Command Flags Flag Description --port Port to listen on (default: 8000) --rendering Demo rendering mode: light (full UI), shadow (Shadow DOM), or chromeless (minimal, no UI) (default: light) --no-reload Disable live reload --target TypeScript/JavaScript transform target: es2015, es2016, es2017, es2018, es2019, es2020, es2021, es2022, es2023, esnext (default: es2022) --no-import-map-generate Disable automatic import map generation from package.json --import-map-override-file Path to JSON file with custom import map entries (merged with auto-generated map) --css-transform Glob patterns for CSS files to transform to JavaScript modules (opt-in, e.g., src/**/*.css,elements/**/*.css) --css-transform-exclude Glob patterns for CSS files to exclude from transformation (e.g., demo/**/*.css) --watch-ignore Glob patterns to ignore in file watcher (comma-separated, e.g., _site/**,dist/**) Global Flags Flag Description --config Path to config file (default: .config/cem.yaml) --package, -p Deno-style package specifier (e.g., npm:@scope/package) or path to package directory --source-control-root-url Canonical public source control URL for primary branch (e.g., https://github.com/user/repo/tree/main/) --quiet, -q Quiet output (only warnings and errors) --verbose, -v Verbose logging output Examples Basic usage cem serve Starts the server on http://localhost:8000.\nCommon options # Use a different port cem serve --port 3000 # Disable live reload cem serve --no-reload # Use chromeless mode for testing cem serve --rendering=chromeless # Configure TypeScript target cem serve --target es2020 # Ignore build directories in watcher cem serve --watch-ignore \u0026#39;dist/**,_site/**\u0026#39; Configuration All command-line flags have corresponding configuration file options. See Configuration for the complete reference.\nExample .config/cem.yaml:\nserve: port: 3000 demos: rendering: shadow target: es2020 transforms: css: include: - \u0026#39;src/**/*.css\u0026#39; exclude: - \u0026#39;demo/**/*.css\u0026#39; importMap: generate: true overrideFile: \u0026#39;.config/importmap.json\u0026#39; urlRewrites: - urlPattern: \u0026#34;/dist/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; watch: ignore: - \u0026#39;dist/**\u0026#39; - \u0026#39;_site/**\u0026#39; See Also Development Workflow - Using the dev server in your workflow Buildless Development - TypeScript and CSS transformation Rendering Modes - Light, shadow, and chromeless modes Import Maps - Using npm packages without bundling Configuration - Complete configuration reference ","link":"https://bennypowers.dev/cem/docs/reference/commands/serve/","section":"docs","title":"Serve"},{"body":"Learn how to use CEM effectively in your development workflow.\nGetting Started Create your first project and component with CEM. Development Workflow Understanding the write → generate → serve → test cycle. Examples Overview Browse starter projects and choose the right template for your needs. Working with Demos Create, organize, and configure component demos. Buildless Development Write TypeScript and CSS without build steps. Import Maps Manage dependencies without bundling. Interactive Knobs Add controls for testing component variations. Rendering Modes Light DOM, shadow DOM, and iframe rendering options. Using LSP Features Leverage autocomplete, validation, and navigation in your editor. Effective MCP Descriptions Write AI-friendly component documentation. ","link":"https://bennypowers.dev/cem/docs/usage/","section":"docs","title":"Usage Guides"},{"body":" TL;DR: Use JSDoc tags (@slot, @csspart, @cssprop, @fires, @attr) to document your components. These power autocomplete, validation, AI assistants, and interactive controls. See examples below. Use JSDoc comments to document your custom elements for the manifest . The manifest powers LSP features like autocomplete and validation, enables AI assistants to understand your components, and drives the dev server\u0026rsquo;s interactive controls .\nJSDoc Tags Use these tags in your element class and member JSDoc comments. See the generate command reference for the complete list.\nBasic Example import { LitElement, html, css } from \u0026#39;lit\u0026#39;; import { customElement, property } from \u0026#39;lit/decorators.js\u0026#39;; /** * Displays a personalized greeting message * * @summary A simple greeting component * @slot - Default slot for custom content * @csspart greeting - The greeting text container * @cssprop --greeting-color - Text color (default: currentColor) */ @customElement(\u0026#39;hello-world\u0026#39;) export class HelloWorld extends LitElement { /** * The name to greet */ @property() name = \u0026#39;World\u0026#39;; render() { return html` \u0026lt;div id=\u0026#34;greeting\u0026#34; part=\u0026#34;greeting\u0026#34;\u0026gt; Hello, ${this.name}! \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; `; } } Specifying Tag Names When the tag name can\u0026rsquo;t be detected automatically, use @customElement, @element, or @tagName:\n/** * A vanilla custom element * * @customElement vanilla-element */ class MyElement extends HTMLElement { static is = \u0026#39;vanilla-element\u0026#39;; static { customElements.define(this.is, this); } } All three tags are aliases and work identically:\n@customElement vanilla-element (recommended) @element vanilla-element @tagName vanilla-element The generator automatically detects tag names from the @customElement decorator and customElements.define('tag-name', Class) calls with static strings. However, when using dynamic patterns like customElements.define(this.is, this) where the tag name is stored in a variable, you must use one of the JSDoc tags above to specify the tag name explicitly.\nDocumenting Slots and Parts cem automatically detects \u0026lt;slot\u0026gt; elements and part attributes in your template. You can add descriptions using JSDoc tags or inline HTML comments.\nHTML Comment Documentation Use plain comments for descriptions:\n\u0026lt;!-- This is the **default** `slot`. --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; Or use YAML for detailed metadata:\n\u0026lt;!-- summary: The main slot for content description: | This slot displays user-provided content. Supports multiline **markdown**. deprecated: true --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; When an element has both a slot and part attribute:\n\u0026lt;!-- slot: summary: The `info` slot part: summary: The `info-part` part --\u0026gt; \u0026lt;slot name=\u0026#34;info\u0026#34; part=\u0026#34;info-part\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; When including inline markdown `code` in lit-html templates, escape the backticks in the comment. Documenting CSS Custom Properties Document CSS variables using JSDoc-style comments in your CSS:\n:host { /** * A property defined on the host * @summary The host\u0026#39;s custom property */ --host-property: red; color: /** * Custom color for use in this element * @summary color * @deprecated Use the `color` property instead */ var(--custom-color); border: 1px solid /** Border color of the element */ var(--border-color); } Position comments correctly when both LHS and RHS contain CSS custom properties:\n/** Comment for --a */ color: var(--a); /** Comment for --b */ --b: blue; /** Comment for --c */ --c: /** Comment for --d */ var(--d); Design Token Integration Use the --design-tokens flag to integrate DTCG-format design tokens:\ncem generate --design-tokens npm:@my-ds/tokens/tokens.json When both user comments and design token descriptions exist for the same property, both are included (user description first, then design token description).\nDocumenting Demos JSDoc @demo Tag Link to demos directly from your element class:\n/** * @demo https://example.com/my-element-plain/ * @demo https://example.com/my-element-fancy/ - A fancier demo */ @customElement(\u0026#39;my-element\u0026#39;) class MyElement extends LitElement { } Automatic Demo Discovery Configure automatic discovery in .config/cem.yaml:\nsourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: demoDiscovery: fileGlob: \u0026#34;src/**/demos/*.html\u0026#34; urlPattern: \u0026#34;/src/:tag/demos/:demo.html\u0026#34; urlTemplate: \u0026#34;https://example.com/elements/{{.tag | alias}}/{{.demo | slug}}/\u0026#34; Template functions:\nalias - Apply element alias mapping slug - Convert to URL-friendly format lower - Convert to lowercase upper - Convert to uppercase See Working with Demos for organization strategies.\nCode Examples Use the @example tag for code examples:\n/** * @example Basic usage * ```html * \u0026lt;my-element\u0026gt;\u0026lt;/my-element\u0026gt; * ``` */ @customElement(\u0026#39;my-element\u0026#39;) class MyElement extends LitElement { } With explicit caption:\n/** * @example * \u0026lt;caption\u0026gt;Advanced usage with properties\u0026lt;/caption\u0026gt; * ```html * \u0026lt;my-element color=\u0026#34;primary\u0026#34; size=\u0026#34;large\u0026#34;\u0026gt;\u0026lt;/my-element\u0026gt; * ``` */ Multiple examples:\n/** * A flexible element * @example Simple case * ```html * \u0026lt;my-element\u0026gt;\u0026lt;/my-element\u0026gt; * ``` * @example With attributes * ```html * \u0026lt;my-element foo=\u0026#34;bar\u0026#34;\u0026gt;\u0026lt;/my-element\u0026gt; * ``` */ Examples with captions are wrapped in \u0026lt;figure\u0026gt;/\u0026lt;figcaption\u0026gt; elements in the generated manifest.\nDocumenting Methods Document public methods using @param and @returns tags:\n/** * Updates the element\u0026#39;s theme * * @summary Apply a new theme * @param {string} themeName - Name of the theme to apply * @param {boolean} [persist=false] - Whether to save theme preference * @returns {boolean} True if theme was applied successfully * @example * ```typescript * element.setTheme(\u0026#39;dark\u0026#39;, true); * ``` */ setTheme(themeName: string, persist = false): boolean { // implementation } Parameter syntax:\nRequired: @param {type} name - description Optional: @param {type} [name] - description With default: @param {type} [name=default] - description Monorepo Setup For npm or yarn workspaces, create a .config/cem.yaml file in each package:\nRoot package.json:\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;npm run generate --workspaces\u0026#34; }, \u0026#34;workspaces\u0026#34;: [\u0026#34;./core\u0026#34;, \u0026#34;./elements\u0026#34;] } core/.config/cem.yaml:\ngenerate: files: - \u0026#39;./**/*.ts\u0026#39; core/package.json:\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;cem generate\u0026#34; } } Repeat for each workspace package.\nSee Also Development Workflow - When to regenerate the manifest Generate Command - Complete JSDoc tag reference and command options Working with Demos - Demo organization strategies Effective Writing for AI - AI-friendly documentation patterns ","link":"https://bennypowers.dev/cem/docs/usage/documenting-components/","section":"docs","title":"Documenting Components"},{"body":"The cem repository includes several example projects that demonstrate different approaches and complexity levels. Each example is a complete, working project you can explore, copy, and adapt to your needs. Don\u0026rsquo;t overthink which one to start with—pick one that sounds interesting, run npm install \u0026amp;\u0026amp; npm run serve, and start experimenting.\nAvailable Examples minimal — The simplest possible custom element with one property, one slot, and basic JSDoc. Perfect for your first cem project or when you just want to see how the manifest workflow works. If you\u0026rsquo;re brand new to cem, start here.\nintermediate — Multiple components that work together, showing realistic patterns like component composition and custom events. Use this as a template when building actual component libraries.\nkitchen-sink — A production-ready button component demonstrating every cem feature: properties, slots, events, CSS parts, CSS custom properties, design tokens, form integration, and comprehensive documentation. Reference this when you need to see how a specific feature is documented.\nai-friendly-docs — Comprehensive JSDoc documentation patterns for AI-friendly component descriptions, demonstrating RFC 2119 keywords, detailed event documentation, slot descriptions, and CSS property guidance. Use this as a reference for writing effective component documentation that works well with AI assistants.\nvanilla — Pure Web Components without Lit or any framework, using only native browser APIs. Choose this if you prefer framework-free development or want to understand how cem works with vanilla JavaScript.\ntypescript-paths — Demonstrates TypeScript path aliases and complex compiler configurations. Use this if your project has custom import resolution or monorepo setup.\nQuick Start Clone the repository and run any example:\ngit clone https://github.com/bennypowers/cem.git cd cem/examples/minimal # or any other example npm install npm run serve # Start dev server Each example includes its own README with details about what it demonstrates and how to use it.\nWhich One Should I Use? Start with minimal if you\u0026rsquo;re learning cem. Use intermediate as a template for real projects. Check kitchen-sink to see specific features in action. Refer to ai-friendly-docs for comprehensive JSDoc patterns. Try vanilla if you prefer framework-free code. See typescript-paths for complex TypeScript setups.\nThe examples are meant to be copied and modified. Take what works, remove what doesn\u0026rsquo;t, and adapt them to your project\u0026rsquo;s needs.\nSee Also Getting Started - Complete walkthrough for your first project Development Workflow - Understanding the write-generate-serve-test cycle Configuration Reference - All config options explained ","link":"https://bennypowers.dev/cem/docs/usage/examples/","section":"docs","title":"Example Projects"},{"body":"Language Server Protocol implementation for custom elements. See LSP Integration for editor setup and Using LSP Features for usage guidance.\nSupported LSP Methods Text Document Features textDocument/hover - Show element and attribute documentation on hover textDocument/completion - Provide tag and attribute completion suggestions textDocument/definition - Jump to custom element source definitions textDocument/publishDiagnostics - Report validation errors with intelligent suggestions textDocument/codeAction - Provide one-click autofixes for validation errors textDocument/didOpen - Track when documents are opened in the editor textDocument/didChange - Handle incremental document changes textDocument/didClose - Clean up resources when documents are closed Workspace Features workspace/symbol - Search and navigate custom elements across the entire workspace Server Lifecycle initialize - Establish server capabilities and workspace configuration shutdown - Gracefully terminate the language server $/setTrace - Control debug logging verbosity (LSP standard) Initialization Options The LSP server accepts custom initialization options for loading additional packages:\n{ \u0026#34;initializationOptions\u0026#34;: { \u0026#34;additionalPackages\u0026#34;: [ \u0026#34;npm:@rhds/elements@2.0.0\u0026#34;, \u0026#34;https://cdn.jsdelivr.net/npm/@shortfuse/materialdesignweb/\u0026#34;, \u0026#34;jsr:@example/elements\u0026#34; ] } } VS Code Example In your VS Code settings.json:\n{ \u0026#34;cem.additionalPackages\u0026#34;: [ \u0026#34;npm:@rhds/elements@2.0.0\u0026#34;, \u0026#34;https://cdn.jsdelivr.net/npm/@example/components/\u0026#34; ] } The VS Code extension passes these as initializationOptions.additionalPackages to the LSP server.\nSupported Specifiers Format Example npm specifier npm:@scope/package@version jsr specifier jsr:@scope/package CDN URL https://cdn.jsdelivr.net/npm/@scope/package/ Note: URLs must point to the package root (where package.json lives). The server reads the customElements field from package.json to locate the manifest.\n","link":"https://bennypowers.dev/cem/docs/reference/lsp/","section":"docs","title":"Language Server"},{"body":"Configure the CEM Model Context Protocol (MCP) server to give AI assistants intelligent access to your custom elements manifests.\nPrerequisites Install CEM first if you haven\u0026rsquo;t already.\nWhat is MCP? The Model Context Protocol enables AI assistants to access structured data about your custom elements. The CEM MCP server transforms your manifests into an AI-accessible interface for:\nGenerating correct HTML with proper slots and attributes Understanding component APIs and relationships Providing CSS integration guidance Validating custom element usage patterns Quick Start Test that MCP is working:\ncem mcp The server starts and communicates via stdio. Press Ctrl+C to stop.\nAI Client Configuration Claude Desktop Add CEM to your Claude Desktop configuration file:\nmacOS: ~/Library/Application Support/Claude/claude_desktop_config.json Windows: %APPDATA%\\Claude\\claude_desktop_config.json\n{ \u0026#34;mcpServers\u0026#34;: { \u0026#34;cem\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;cem\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;mcp\u0026#34;] } } } Loading Additional Packages To include elements from external packages (npm, CDN URLs, or jsr specifiers):\n{ \u0026#34;mcpServers\u0026#34;: { \u0026#34;cem\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;cem\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;mcp\u0026#34;, \u0026#34;--additional-packages\u0026#34;, \u0026#34;npm:@rhds/elements@2.0.0\u0026#34;, \u0026#34;--additional-packages\u0026#34;, \u0026#34;https://cdn.jsdelivr.net/npm/@shortfuse/materialdesignweb/\u0026#34; ] } } } Alternatively, configure additional packages in your project\u0026rsquo;s .config/cem.yaml:\nadditionalPackages: - npm:@rhds/elements@2.0.0 - https://cdn.jsdelivr.net/npm/@shortfuse/materialdesignweb/ Restart Claude Desktop for changes to take effect.\nClaude Code Install the CEM plugin which includes both LSP and MCP support:\n/plugin marketplace add bennypowers/cem /plugin install cem The MCP server activates automatically when the plugin is installed.\nCursor Add CEM to your Cursor MCP configuration. See Cursor MCP integration docs for configuration file location and format.\nContinue.dev Add CEM to your Continue MCP setup. See Continue MCP setup docs for configuration instructions.\nOther MCP Clients The CEM MCP server works with any MCP-compatible AI client that supports stdio transport. Configure your client to run:\ncem mcp See the MCP specification for details on client implementation.\nVerify Installation After configuring your AI client:\nAsk the AI: \u0026ldquo;What custom elements are available in my project?\u0026rdquo; The AI should list your components from the manifest Try generation: \u0026ldquo;Generate a card component with my-card element\u0026rdquo; If the AI can\u0026rsquo;t access your components:\nEnsure you have a custom-elements.json in your project (run cem generate) Restart your AI client after configuration changes Check that cem mcp runs without errors when executed directly Debugging MCP Inspector Use the MCP Inspector for interactive debugging:\n# Install MCP Inspector npm install -g @modelcontextprotocol/inspector # Debug CEM MCP server mcp-inspector cem mcp The inspector provides a web UI for:\nTesting resources and tools interactively Viewing real-time server logs Validating resource URIs and tool parameters Debugging protocol communication Verbose Logging Enable detailed logging to troubleshoot issues:\ncem mcp --verbose Or with the inspector:\nmcp-inspector cem mcp --verbose Debug Specific Projects Use the --package flag to debug different project directories:\nmcp-inspector cem mcp --package /path/to/project Common Issues Server won\u0026rsquo;t start:\n# Check workspace has manifests cem list # Verify workspace structure cem validate No elements found:\n# Generate manifests first cem generate # Check workspace context ls custom-elements.json package.json Connection issues:\nEnsure cem mcp runs without errors Check that manifest files exist in your workspace Verify your AI client is configured for stdio transport Restart your AI client after configuration changes Next Steps Effective MCP Descriptions - Write AI-friendly documentation MCP Protocol Reference - Technical API details Getting Started - Create your first project ","link":"https://bennypowers.dev/cem/docs/installation/mcp/","section":"docs","title":"MCP Integration"},{"body":"Technical API documentation and configuration reference.\nCommands Command-line interface reference for all CEM commands. Configuration Complete configuration file reference and options. LSP Protocol Language Server Protocol specification and API details. MCP Protocol Model Context Protocol specification and API details. ","link":"https://bennypowers.dev/cem/docs/reference/","section":"docs","title":"Reference"},{"body":" TL;DR: Create HTML files showcasing your components. Add @demo JSDoc tags for automatic discovery, or configure demoDiscovery patterns in cem.yaml. Demos are HTML partials—the server adds the wrapper, import maps, and live reload. Demos are HTML files that showcase your custom elements in action. They serve as living documentation, manual test cases, and interactive examples for users exploring your components. The cem dev server discovers demos from @demo JSDoc tags (always works) or by file pattern matching (requires demoDiscovery configuration), then wraps them in minimal chrome with live reload and navigation UI. You can organize demos by component, by feature, or use a hybrid approach—whatever makes sense for your project.\nDemos are HTML partials, not full documents. You write just the content you want to showcase, and the dev server handles the document wrapper, import maps, TypeScript transformation, and error overlay. Demos fit naturally into the development workflow —create them as you build components, use them during the test phase , and update them when you edit APIs. Use HTML5 microdata to add descriptions, control URLs, and explicitly associate demos with elements. For advanced URL generation and path-based discovery, configure URLPattern matching and URL templates in your cem.yaml.\nDemo Discovery cem discovers demos in two ways: via JSDoc, and by configuring automatic demo discovery in cem.yaml .\nManifest Demos Field Explicitly list demos in your manifest using the @demo JSDoc tag:\n/** * My awesome button component * * @demo elements/my-button/demos/basic.html Basic usage * @demo elements/my-button/demos/variants.html All variants */ @customElement(\u0026#39;my-button\u0026#39;) export class MyButton extends LitElement { // ... } When you run cem generate, these demos are added to the manifest and automatically linked to your component. This approach gives you explicit control over demo ordering and descriptions, provides clear documentation of available demos, and works seamlessly in published packages.\nImportant: Paths in @demo tags are relative to your project root, not to the component file.\nFile Pattern Matching Recommended approach: Configure cem to discover demos by glob pattern.\nRequired configuration in .config/cem.yaml:\ngenerate: demoDiscovery: fileGlob: elements/**/demo/*.html Without this configuration, file-based discovery won\u0026rsquo;t happen—only @demo JSDoc tags will work.\nCommon patterns:\n# Demos in demos/ subdirectories (recommended) fileGlob: elements/**/demo/*.html # Demos named *.demo.html fileGlob: elements/**/*.demo.html Example structure with fileGlob: \u0026quot;elements/**/demo/*.html\u0026quot;:\nelements/ └── my-button/ ├── my-button.ts └── demos/ ├── index.html # ✅ Matched by fileGlob ├── variants.html # ✅ Matched by fileGlob └── advanced.html # ✅ Matched by fileGlob See Configuration Reference for all options.\nURL Generation with URLPattern For advanced demo URL generation, configure URLPattern matching and URL templates. The urlTemplate uses Go template syntax to generate URLs from those captured parameters. See the example projects for more.\ngenerate: demoDiscovery: fileGlob: elements/**/demo/*.html urlPattern: /elements/:element/demo/:demo.html urlTemplate: https://example.com/{{.element | alias}}/{{.demo | slug}}/ Available template functions:\nFunction Description Example alias Apply element alias mapping {{.tag | alias}} slug Convert to URL-friendly slug {{.demo | slug}} lower Convert to lowercase {{.component | lower}} upper Convert to uppercase {{.section | upper}} Template examples:\n# Basic interpolation urlTemplate: https://example.com/{{.component}}/{{.demo}}/ # With alias transformation urlTemplate: https://example.com/{{.component | alias}}/{{.demo}}/ # Chain multiple functions urlTemplate: https://example.com/{{.component | alias | slug}}/{{.demo | lower}}/ URLPattern also enables precise path-based demo association, preventing false matches when element aliases are substrings of each other (e.g., preventing \u0026ldquo;accordion\u0026rdquo; from matching \u0026ldquo;accordion-header\u0026rdquo;).\nWriting Demos Demos are HTML partials (not full HTML documents). The dev server wraps them in demo chrome automatically.\ndemos/index.html:\n\u0026lt;my-button\u0026gt;Click Me\u0026lt;/my-button\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import \u0026#39;../my-button.js\u0026#39;; \u0026lt;/script\u0026gt; The server automatically wraps this partial in a full HTML document with viewport meta tag, live reload script, error overlay, and navigation UI. Include styles in your demo with an inline \u0026lt;style\u0026gt; element. We recommend scoping styles using CSS nesting to avoid your styles leaking out into the rest of the demo page.\n\u0026lt;style\u0026gt; my-button { --button-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;my-button\u0026gt;Styled Button\u0026lt;/my-button\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import \u0026#39;../my-button.js\u0026#39;; \u0026lt;/script\u0026gt; You can include as many elements as you want in your demos:\n\u0026lt;my-card\u0026gt; \u0026lt;my-icon slot=\u0026#34;header\u0026#34; icon=\u0026#34;star\u0026#34;\u0026gt;\u0026lt;/my-icon\u0026gt; \u0026lt;h2 slot=\u0026#34;header\u0026#34;\u0026gt;Card Title\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Card content goes here\u0026lt;/p\u0026gt; \u0026lt;my-button slot=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/my-button\u0026gt; \u0026lt;/my-card\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import \u0026#39;../my-card.js\u0026#39;; import \u0026#39;../my-button.js\u0026#39;; import \u0026#39;../my-icon.js\u0026#39;; \u0026lt;/script\u0026gt; Documenting Your Demos Use HTML5 microdata to control demo metadata and association. You can modify the demo\u0026rsquo;s URL, add a description, or explicitly associate that demo with a tag name.\n\u0026lt;meta itemprop=\u0026#34;demo-url\u0026#34; content=\u0026#34;/elements/my-button/demo/\u0026#34;\u0026gt; \u0026lt;meta itemprop=\u0026#34;demo-for\u0026#34; content=\u0026#34;my-button my-card\u0026#34;\u0026gt; \u0026lt;meta itemprop=\u0026#34;description\u0026#34; content=\u0026#34;Basic button demonstration\u0026#34;\u0026gt; The demo-for property is useful when the demo file path doesn\u0026rsquo;t indicate which element it\u0026rsquo;s for, when a demo showcases multiple elements, or when you need to prevent incorrect auto-association.\nRich Descriptions You can also add Markdown scripts to add rich content to your demo\u0026rsquo;s description\n\u0026lt;script type=\u0026#34;text/markdown\u0026#34; itemprop=\u0026#34;description\u0026#34;\u0026gt; Showcases all button variants: - **Primary** - Call to action buttons - **Secondary** - Less prominent actions - **Danger** - Destructive actions \u0026lt;/script\u0026gt; Demo Association Logic CEM uses this priority order to associate demos with elements:\nExplicit microdata - \u0026lt;meta itemprop=\u0026quot;demo-for\u0026quot; content=\u0026quot;element-name\u0026quot;\u0026gt; Path-based - Elements whose aliases appear in demo file paths Content-based - Custom elements found in the demo HTML Path-Based Association When elements use the @alias JSDoc tag, or have configured aliases in cem.yaml:\naliases: my-button: button my-card: card These paths match:\n✅ elements/button/demo/basic.html → my-button ✅ elements/card/demo/index.html → my-card ❌ elements/btn/demo/index.html → No match (alias is \u0026#34;button\u0026#34;, not \u0026#34;btn\u0026#34;) See Also Rendering Modes - Light DOM, shadow DOM, iframe options Interactive Knobs - Add controls to demos Configuration Reference - Complete demo discovery config workflow Development Workflow - How demos fit into the dev cycle ","link":"https://bennypowers.dev/cem/docs/usage/demos/","section":"docs","title":"Element Demos"},{"body":"Model Context Protocol server for custom elements. See MCP Integration for setup.\nMCP Resources URI Description cem://schema JSON schema for custom elements manifests cem://packages Package discovery and overview of available manifest packages cem://elements Summaries of all available elements with capabilities and metadata cem://element/{tagName} Detailed element information including attributes, slots, events, CSS properties, parts, and states cem://element/{tagName}/attributes Attribute documentation with type constraints, valid values, and usage patterns cem://element/{tagName}/slots Content guidelines and accessibility considerations for slots cem://element/{tagName}/events Event triggers, data payloads, and JavaScript integration patterns cem://element/{tagName}/css/parts CSS parts styling guidance cem://element/{tagName}/css/custom-properties CSS custom properties documentation cem://element/{tagName}/css/states CSS custom states documentation cem://guidelines Design system guidelines and best practices cem://accessibility Accessibility patterns and validation rules MCP Tools generate_html Generate correct HTML structure with proper slots and attributes using manifest data.\nParameter Type Required Description tagName string ✅ Element to generate HTML for attributes object Attribute values to include content object Slot content mapping validate_html Validates custom element usage based on manifest guidelines.\nParameter Type Required Description html string ✅ HTML content to validate tagName string Focus validation on specific element context string Validation context for custom elements Validation Types:\nSlot content guidelines Attribute conflicts (e.g., loading=\u0026quot;eager\u0026quot; + lazy=\u0026quot;true\u0026quot;) Content/attribute redundancy Manifest compliance Configuration Claude Desktop { \u0026#34;mcpServers\u0026#34;: { \u0026#34;cem\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;cem\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;mcp\u0026#34;] } } } Other Clients Configure stdio transport with command cem mcp. See MCP specification for details.\nServer Options cem mcp [flags] Flags:\n--package \u0026lt;path\u0026gt; - Specify project directory or package specifier (npm:, jsr:, or URL) --additional-packages \u0026lt;specs\u0026gt; - Load additional packages alongside local project (repeatable) --max-description-length \u0026lt;num\u0026gt; - Override 2000 character description limit --verbose - Enable detailed logging Loading Additional Packages Load elements from external packages that aren\u0026rsquo;t in your local project:\n# Single additional package cem mcp --additional-packages npm:@rhds/elements@2.0.0 # Multiple packages cem mcp --additional-packages npm:@vaadin/button@24.3.5 \\ --additional-packages https://cdn.jsdelivr.net/npm/@example/components/ Or configure in .config/cem.yaml:\nadditionalPackages: - npm:@rhds/elements@2.0.0 - https://cdn.jsdelivr.net/npm/@shortfuse/materialdesignweb/ ","link":"https://bennypowers.dev/cem/docs/reference/mcp/","section":"docs","title":"MCP Server"},{"body":" TL;DR: Import .ts files directly in demos—no build step needed. The dev server transforms TypeScript on-demand with source maps. Use --target es2020 to control browser compatibility and --css-transform patterns to import CSS as JavaScript modules. The cem dev server transforms TypeScript and CSS on-demand, letting you write modern code without running build tools. Write TypeScript directly in your demos with full source map support, import CSS as modules using constructable stylesheets, and configure automatic path rewrites for projects with separate source and output directories. The server respects your tsconfig.json settings and provides browser compatibility control through esbuild targets.\nThis buildless approach eliminates tsc --watch, CSS preprocessors, and bundlers from your development workflow. You write TypeScript and CSS, import them directly in demos, and the dev server handles transformation transparently with full debugging support.\nThe dev server handles TypeScript files (.ts), CSS files as modules (with opt-in patterns), ES modules from npm via import maps, and modern JavaScript syntax. JavaScript files (.js, .mjs), HTML files, and JSON files work as-is without building them ahead-of-time.\nWrite TypeScript Directly Import TypeScript files directly in your demos without compilation:\n\u0026lt;!-- In your demo --\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;../src/my-element.ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; The dev server handles TypeScript transformation on-demand with full source map support for debugging. You don\u0026rsquo;t need to run tsc --watch, set up build pipelines, wait for compilation before testing, or manage separate source and output directories.\nBrowser Compatibility Control which browsers your code supports using the --target flag:\ncem serve --target es2020 The default target is es2022. See esbuild\u0026rsquo;s target documentation for all available targets.\nYour tsconfig.json Works The dev server respects your existing TypeScript configuration including compilerOptions.target, compilerOptions.module, compilerOptions.rootDir and compilerOptions.outDir for src/dist separation, and include and exclude patterns. The command-line --target flag overrides tsconfig.json settings if provided.\nSeparate dist Directory If your project uses separate source and output directories (e.g., src/ and dist/), the dev server automatically handles path resolution so you can reference compiled output paths while serving source files.\nHow it works:\nThe dev server reads your tsconfig.json to detect rootDir and outDir It creates URL rewrites automatically (e.g., \u0026quot;/dist/:path*\u0026quot; → \u0026quot;/src/{{.path}}\u0026quot;) Requests to /dist/components/button.js resolve to /src/components/button.ts Your demos can reference the output path, but the server serves the source Example tsconfig.json:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;ES2022\u0026#34; } } With this configuration, a request to /dist/components/button.js resolves to /src/components/button.ts, which the server transforms and serves as TypeScript source.\nThis lets you write demos using the same paths your production build uses without changing import paths between development and production. It works seamlessly with TypeScript\u0026rsquo;s project references and supports monorepo/workspace setups with per-package tsconfig.json files.\nFallback behavior:\nIf the dev server can\u0026rsquo;t find a source file via URL rewrites, it tries co-located files (in-place compilation). This ensures backward compatibility with projects that compile TypeScript in the same directory as source files.\nManual configuration:\nIf you need custom URL rewrites beyond what tsconfig.json provides, configure them using URLPattern syntax and Go templates:\nserve: urlRewrites: # Simple prefix mapping - urlPattern: \u0026#34;/dist/:path*\u0026#34; urlTemplate: \u0026#34;/src/{{.path}}\u0026#34; # Custom library paths - urlPattern: \u0026#34;/lib/:path*\u0026#34; urlTemplate: \u0026#34;/sources/{{.path}}\u0026#34; # Pattern with template function - urlPattern: \u0026#34;/api/:version/:endpoint*\u0026#34; urlTemplate: \u0026#34;/{{.version | lower}}/api/{{.endpoint}}\u0026#34; Pattern syntax:\nURL patterns use URLPattern syntax:\n:param - Matches a single path segment and captures it as a named parameter ** - Matches any number of path segments (wildcard) * - Matches characters within a single segment URL templates use Go template syntax:\n{{.param}} - Inserts a captured parameter {{.param | lower}} - Applies the lower function (converts to lowercase) {{.param | upper}} - Applies the upper function (converts to uppercase) {{.param | slug}} - Applies the slug function (URL-safe slug) Example: Element name transformation for demos\nIf your project serves demos at URLs that don\u0026rsquo;t match the on-disk structure:\nOn disk: elements/my-card/demo/card.html Served URL: /elements/card/demo/card/ CSS reference in demo: \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;../my-card-lightdom.css\u0026quot;\u0026gt; Browser resolves to: /elements/card/demo/my-card-lightdom.css ❌ This can happen when your demo files load files by relative path from, since the dev server prettifies their URLs (card.html =\u0026gt; card/index.html).\nConfigure URL rewrites to fix the mismatch:\nserve: urlRewrites: - urlPattern: \u0026#34;/elements/:slug/demo/:rest*.css\u0026#34; urlTemplate: \u0026#34;/elements/my-{{.slug}}/{{.rest}}.css\u0026#34; This resolves /elements/card/demo/my-card-lightdom.css → elements/my-card/my-card-lightdom.css ✓\nSee Configuration for details.\nImport CSS as Modules The dev server supports two ways to import CSS files as constructable stylesheets. Import attributes with with { type: 'css' } work automatically without configuration, while plain imports require glob pattern configuration.\nImport Attributes Use the standard import attributes syntax for automatic CSS transformation:\nimport styles from \u0026#39;./my-element.css\u0026#39; with { type: \u0026#39;css\u0026#39; }; class MyElement extends HTMLElement { constructor() { super(); this.attachShadow({ mode: \u0026#39;open\u0026#39; }); this.shadowRoot.adoptedStyleSheets = [styles]; } } This modern, standards-based syntax always transforms CSS to modules—no configuration needed. The dev server rewrites with { type: 'css' } to query parameters during TypeScript transformation, then transforms the CSS file to a JavaScript module that exports a CSSStyleSheet object.\nPlain Imports (Requires Configuration) Alternatively, use plain imports without the with keyword:\nimport styles from \u0026#39;./my-element.css\u0026#39;; class MyElement extends HTMLElement { constructor() { super(); this.attachShadow({ mode: \u0026#39;open\u0026#39; }); this.shadowRoot.adoptedStyleSheets = [styles]; } } Plain imports only transform CSS files matching glob patterns that you configure via command line or config file:\nVia command line:\ncem serve --css-transform \u0026#39;src/**/*.css\u0026#39; --css-transform \u0026#39;elements/**/*.css\u0026#39; Via config file:\nserve: transforms: css: include: - src/**/*.css - elements/**/*.css exclude: - demo/**/*.css Without glob patterns, plain CSS imports won\u0026rsquo;t transform—only imports with with { type: 'css' } work. This prevents \u0026lt;link rel=\u0026quot;stylesheet\u0026quot;\u0026gt; tags from breaking unexpectedly. Debugging Source maps work automatically, so stack traces point to your original TypeScript, browser DevTools show your source files, and breakpoints work in TypeScript rather than generated JavaScript.\nConfiguration Via Command Line cem serve --target es2020 --css-transform \u0026#39;src/**/*.css\u0026#39; Via Config File serve: target: es2020 transforms: css: include: - \u0026#39;src/**/*.css\u0026#39; See Configuration for all options.\nWhat\u0026rsquo;s Next? Import Maps - Use npm packages without bundling Configuration - Configuration reference Getting Started - Set up your first demo ","link":"https://bennypowers.dev/cem/docs/usage/buildless-development/","section":"docs","title":"Buildless Development"},{"body":"The dev server automatically generates import maps from your package.json, letting you use npm packages in demos without bundling. Import maps enable standard bare specifiers like import { LitElement } from 'lit' instead of relative paths to node_modules, supporting both single packages and npm workspaces monorepos. This complements buildless TypeScript development by eliminating the need for bundlers while preserving the same import syntax you\u0026rsquo;d use in production code.\nImport maps work by mapping package names to file paths, so import { LitElement } from 'lit' resolves to /node_modules/lit/index.js. The dev server reads your package.json dependencies, resolves entry points from each package\u0026rsquo;s exports or main field, and injects the generated import map into demo HTML automatically.\nAutomatic Generation The dev server reads your package.json and generates an import map for all dependencies:\npackage.json:\n{ \u0026#34;dependencies\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;^3.0.0\u0026#34;, \u0026#34;@patternfly/elements\u0026#34;: \u0026#34;^3.0.0\u0026#34; } } Generated import map:\n{ \u0026#34;imports\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;/node_modules/lit/index.js\u0026#34;, \u0026#34;lit/\u0026#34;: \u0026#34;/node_modules/lit/\u0026#34;, \u0026#34;@patternfly/elements\u0026#34;: \u0026#34;/node_modules/@patternfly/elements/pfe.min.js\u0026#34;, \u0026#34;@patternfly/elements/\u0026#34;: \u0026#34;/node_modules/@patternfly/elements/\u0026#34; } } NPM Workspaces Support For npm workspaces monorepos, the dev server discovers all workspace packages, generates import maps for each package\u0026rsquo;s dependencies, then aggregates them into a single import map. Workspace packages become importable by name, so import { MyButton } from '@my-org/button' works across packages in your monorepo just like external dependencies:\n{ \u0026#34;imports\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;/node_modules/lit/index.js\u0026#34;, \u0026#34;@my-org/button\u0026#34;: \u0026#34;/pkg/@my-org/button/src/index.js\u0026#34;, \u0026#34;@my-org/card\u0026#34;: \u0026#34;/pkg/@my-org/card/src/index.js\u0026#34; } } Package Exports Support The dev server respects package.json exports field:\n{ \u0026#34;name\u0026#34;: \u0026#34;my-package\u0026#34;, \u0026#34;exports\u0026#34;: { \u0026#34;.\u0026#34;: \u0026#34;./dist/index.js\u0026#34;, \u0026#34;./button\u0026#34;: \u0026#34;./dist/button.js\u0026#34;, \u0026#34;./card\u0026#34;: \u0026#34;./dist/card.js\u0026#34; } } Result:\n{ \u0026#34;imports\u0026#34;: { \u0026#34;my-package\u0026#34;: \u0026#34;/node_modules/my-package/dist/index.js\u0026#34;, \u0026#34;my-package/button\u0026#34;: \u0026#34;/node_modules/my-package/dist/button.js\u0026#34;, \u0026#34;my-package/card\u0026#34;: \u0026#34;/node_modules/my-package/dist/card.js\u0026#34; } } Prefix Matching The dev server includes prefix mappings (trailing /) for subpath imports:\n// Both work: import { MyElement } from \u0026#39;@my-org/elements\u0026#39;; import { utils } from \u0026#39;@my-org/elements/utils.js\u0026#39;; Debugging View the import map Look in the HTML source of any demo page:\n\u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; { \u0026#34;imports\u0026#34;: { \u0026#34;lit\u0026#34;: \u0026#34;/node_modules/lit/index.js\u0026#34;, ... } } \u0026lt;/script\u0026gt; Check server logs With --verbose flag, see import map generation:\ncem serve --verbose Look for log entries like:\n[INFO] Generated import map with 23 entries [DEBUG] Import map entry: lit -\u0026gt; /node_modules/lit/index.js Custom Overrides You can customize import map entries to point packages to CDNs, fix broken package exports, or use local development builds. The dev server resolves entries with this priority: auto-generated from package.json (lowest), override file entries (medium), and config overrides (highest priority wins).\nSpecify overrides directly in .config/cem.yaml using the full import map format :\nserve: importMap: override: imports: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/+esm\u0026#39; \u0026#39;lit/\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@3/\u0026#39; \u0026#39;@my-org/components\u0026#39;: \u0026#39;/dist/components.js\u0026#39; scopes: \u0026#39;/demos/legacy/\u0026#39;: \u0026#39;lit\u0026#39;: \u0026#39;https://cdn.jsdelivr.net/npm/lit@2/+esm\u0026#39; Alternatively, use an override file for complex mappings. Create .config/importmap.json with standard import map format, then reference it in your config:\nserve: importMap: overrideFile: \u0026#39;.config/importmap.json\u0026#39; To disable automatic generation and use only your override file, set generate: false or use the --no-import-map-generate flag.\nWhat\u0026rsquo;s Next? Buildless Development - TypeScript and CSS without build steps Configuration - Complete configuration reference Getting Started - Set up your first demo ","link":"https://bennypowers.dev/cem/docs/usage/import-maps/","section":"docs","title":"Import Maps"},{"body":" TL;DR: Knobs are auto-generated controls in the dev server sidebar based on your JSDoc types. Booleans become checkboxes, unions become dropdowns, numbers get steppers. Run cem generate with proper type annotations to get better controls. The dev server generates interactive controls (knobs) that let you test custom elements by manipulating their attributes, properties, and CSS custom properties in real-time. Knobs are automatically generated from your Custom Elements Manifest , so the type information and documentation you write with JSDoc directly determines which controls appear in the sidebar. This complements the development workflow by providing immediate visual feedback during the test phase , letting you verify component behavior across different states without writing test HTML for each variation.\nKnobs derive entirely from your manifest—when you run cem generate , your JSDoc type annotations determine the control type. Boolean attributes become checkboxes, union types become select dropdowns, numbers get increment/decrement controls, and CSS color properties get color pickers. The dev server scans your demo HTML for custom elements, looks up each element\u0026rsquo;s manifest entry, and creates labeled control groups in the sidebar.\nThe Workflow c C e o @ @ @ m m a p c p t r s g o t o s e n r p p n e r e n o r t p a t e a m c S I S K M t e s w n e n a t m s i p l o n r b P t u e b i s e r c t c s f [ r o c h t e ] s p e s s m t s e r v e Everything derives from your component documentation - the manifest is the single source of truth.\nHow Knobs Map to Controls The dev server reads your manifest\u0026rsquo;s attributes array (DOM attributes like disabled), members array (JavaScript properties like data), and cssProperties array (CSS variables like --bg-color). Each entry\u0026rsquo;s type information determines which control appears—boolean types become checkboxes, union types become select dropdowns, numbers get increment/decrement controls, and CSS color values get color pickers with hex input.\nType Control Example boolean Checkbox @attr {boolean} disabled string Text input @attr {string} label number Number input @property {number} count 'a' | 'b' | 'c' Select dropdown @attr {'primary' | 'secondary'} variant CSS color Color picker @cssprop --bg-color TypeScript and Lit Support If you\u0026rsquo;re using Lit with TypeScript, cem generate automatically infers type information from decorators and TypeScript annotations—no JSDoc required. The @property() decorator with TypeScript types provides everything needed for knobs generation:\nimport { LitElement, html } from \u0026#39;lit\u0026#39;; import { customElement, property } from \u0026#39;lit/decorators.js\u0026#39;; @customElement(\u0026#39;my-element\u0026#39;) export class MyElement extends LitElement { // Boolean type → checkbox knob @property({ type: Boolean }) disabled = false; // String type → text input knob @property() name = \u0026#39;World\u0026#39;; // Number type → number input knob @property({ type: Number }) count = 0; // Union type → select dropdown knob @property() variant: \u0026#39;primary\u0026#39; | \u0026#39;secondary\u0026#39; | \u0026#39;danger\u0026#39; = \u0026#39;primary\u0026#39;; } CSS custom properties can be documented either with @cssprop JSDoc tags in your component class or with JSDoc-style comments directly in your CSS (recommended):\nstatic styles = css` :host { /** --button-bg: Background color (default: #0066cc) */ background: var(--button-bg, #0066cc); /** --button-padding: Internal padding (default: 8px 16px) */ padding: var(--button-padding, 8px 16px); } `; For detailed descriptions, usage examples, or additional metadata beyond what TypeScript provides, add JSDoc comments to supplement the type information.\nMultiple Element Instances The dev server generates knobs for every custom element in your demo that\u0026rsquo;s documented in the manifest. When you have multiple instances of the same element, each gets a unique label based on its id attribute, text content (first 20 characters), aria-label, or a fallback like \u0026ldquo;tag-name No. N\u0026rdquo;. Each instance\u0026rsquo;s knobs are independent—changing a knob updates only that specific element.\nKnobs are organized into collapsible categories: Attributes for DOM attributes like disabled, Properties for JavaScript properties like data, and CSS Properties for custom properties like --bg-color.\nTroubleshooting If knobs don\u0026rsquo;t appear, verify your manifest has API documentation by running cem generate and checking that custom-elements.json contains attributes, properties, or cssProperties for your element. Make sure the element appears in your demo HTML and uses proper JSDoc tags like @attr, @property, and @cssprop.\nIf a knob shows the wrong control type (checkbox instead of text input), check that your JSDoc type annotation matches the actual type—@attr {boolean} for booleans, @attr {string} for strings. Regenerate the manifest with cem generate after fixing JSDoc, then restart the dev server.\nIf a knob doesn\u0026rsquo;t update your element, ensure your component responds to attribute changes using attributeChangedCallback or property setters that trigger rendering. Check the browser console for JavaScript errors that might prevent updates.\nExample: Complete Component Here\u0026rsquo;s a well-documented component that gets full knobs support:\n/** * A customizable button component * * @attr {string} variant - Visual style: \u0026#39;primary\u0026#39;, \u0026#39;secondary\u0026#39;, \u0026#39;danger\u0026#39; * @attr {boolean} disabled - Disables the button * @attr {string} label - Accessible label for the button * * @property {number} clickCount - Number of times button was clicked * * @cssprop --button-bg - Background color (default: #0066cc) * @cssprop --button-padding - Internal padding (default: 8px 16px) * * @customElement my-button */ class MyButton extends HTMLElement { // Implementation... } This generates:\nAttributes: variant (select), disabled (checkbox), label (text) Properties: clickCount (number) CSS Properties: \u0026ndash;button-bg (color), \u0026ndash;button-padding (text) What\u0026rsquo;s Next? Generate Command - JSDoc syntax for documenting components Development Workflow - How knobs fit into the write-generate-serve-test cycle Demos - Organize demo HTML files ","link":"https://bennypowers.dev/cem/docs/usage/knobs/","section":"docs","title":"Knobs"},{"body":" TL;DR: The LSP provides autocomplete for tag names and attributes, hover docs on elements, and go-to-definition (F12) to jump to source code. Run cem generate to update your manifest and refresh editor features. The Language Server Protocol integration provides editor features like autocomplete, hover documentation, and go-to-definition for custom elements in HTML and TypeScript files. After setting up the LSP , your editor reads your Custom Elements Manifest to power intelligent code completion for tag names, attributes, slot names, and enum values. This complements the development workflow by catching typos and invalid attributes as you write code, reducing the time spent switching between editor and browser during the test phase .\nThe LSP uses your manifest as the source of truth, so running cem generate after documenting components makes those APIs immediately available in your editor. Features work in plain HTML files, Lit template literals, and anywhere custom elements appear in your code.\nAutocomplete Press Ctrl+Space (or your editor\u0026rsquo;s autocomplete trigger) after typing \u0026lt;my-bu to see custom element suggestions like my-button and my-button-group with their descriptions. Type a space after a tag name to see available attributes with type information and descriptions. For attributes with enum values like variant, autocomplete suggests valid options like primary, secondary, and danger. When adding slot=\u0026quot;\u0026quot; attributes, autocomplete suggests valid slot names based on the parent element\u0026rsquo;s documented slots.\nThe LSP works in Lit template literals with special syntax support—use @eventName for events, .propertyName for properties, and ?booleanAttr for boolean attributes. All completions include inline documentation from your manifest.\nHover Documentation Hover over tag names to see element summaries, complete API documentation (properties, attributes, slots, events), CSS custom properties and parts, and links to source code. Attributes show descriptions, type information, default values, and valid enum values when hovered. In CSS files, hovering over ::part() selectors displays styling guidance for that shadow part.\nGo-to-Definition Position your cursor on a tag name like \u0026lt;my-button\u0026gt; and press F12 (VS Code) or ctrl-] (Neovim) to jump to the component source file. Works from attributes too—trigger go-to-definition on variant=\u0026quot;primary\u0026quot; to jump to the property definition in the component class.\nFind References Position your cursor on a custom element tag and press Shift+F12 (VS Code) or gr (Neovim) to see all usages across HTML, TypeScript, and JavaScript files. Results are filtered by .gitignore to exclude node_modules/, show only start tags to avoid duplicates, and work in template literals.\nWorkspace Symbols Press Ctrl+T (VS Code) or use :Telescope lsp_workspace_symbols (Neovim) to search for custom elements across your entire workspace with fuzzy matching. Typing btn finds my-button, icon-button, and button-group.\nError Detection \u0026amp; Quick Fixes The LSP validates HTML and provides one-click fixes for common errors. Position your cursor on red squiggles and press Ctrl+. (VS Code) or \u0026lt;leader\u0026gt;ca (Neovim) to see available fixes.\nDetected errors include invalid slot names (slot=\u0026quot;heade\u0026quot; suggests \u0026quot;header\u0026quot;), typos in tag names (\u0026lt;my-buttom\u0026gt; suggests \u0026lt;my-button\u0026gt;), invalid attribute names (varient suggests variant), invalid enum values (variant=\u0026quot;primar\u0026quot; suggests \u0026quot;primary\u0026quot;), and missing imports (suggests adding import statements for undeclared elements).\nTroubleshooting If autocomplete doesn\u0026rsquo;t work, check that custom-elements.json exists, verify the LSP is running in your editor\u0026rsquo;s status bar, regenerate the manifest with cem generate, and restart your editor if needed.\nIf suggestions are outdated, regenerate the manifest—the LSP watches for changes and reloads automatically. For validation errors that don\u0026rsquo;t appear, check that diagnostics are enabled in your editor and that your manifest contains element schemas.\nFor large projects with performance issues, limit workspace scope, exclude build directories in .gitignore, or enable verbose logging to diagnose what\u0026rsquo;s happening.\nDebug Logging Debug logging is controlled via the LSP standard $/setTrace notification. Most editors expose this through trace level settings:\n\u0026quot;off\u0026quot; - No debug logging (default) \u0026quot;messages\u0026quot; - Basic debug logging \u0026quot;verbose\u0026quot; - Detailed debug logging Enable verbose logging to troubleshoot issues:\nVS Code: Set \u0026quot;cem.lsp.trace.server\u0026quot;: \u0026quot;verbose\u0026quot; in settings.json Neovim: Set trace = 'verbose' in your LSP configuration Other editors: Consult your LSP client documentation for trace level settings\nSee Also LSP Integration - Setup instructions for editors LSP Protocol Reference - Technical implementation details Development Workflow - How LSP fits into the dev cycle ","link":"https://bennypowers.dev/cem/docs/usage/using-lsp/","section":"docs","title":"Using LSP Features"},{"body":" TL;DR: Write JSDoc descriptions that explain what something is for and how to use it. Use RFC 2119 keywords (MUST, SHOULD, AVOID) for validation rules. Keep descriptions under 400 characters for best AI performance (2000 char hard limit). The Model Context Protocol integration uses your Custom Elements Manifest descriptions to help AI systems generate correct HTML, suggest appropriate component usage, validate accessibility compliance, and provide contextual recommendations. After setting up MCP , AI assistants read your manifest to understand component relationships and hierarchies, so well-written descriptions enable intelligent code generation while poor descriptions lead to incorrect or suboptimal output. This complements the development workflow by providing AI assistants with the same component knowledge you document for humans.\nThe CEM MCP server uses a declarative tool framework that transforms your manifest data into context-aware responses for AI systems. Your JSDoc descriptions don\u0026rsquo;t work in isolation—they\u0026rsquo;re combined with type information, schema definitions, and usage patterns to create comprehensive guidance. Use RFC 2119 keywords (MUST, SHOULD, AVOID) in descriptions to create structured guidelines that AI systems extract for validation and code generation.\nDescription Length Limits The CEM MCP server enforces a 2000-character limit on all description fields (elements, attributes, slots, CSS properties, events, and parts) to ensure optimal AI performance. Descriptions exceeding this limit are automatically truncated with \u0026ldquo;\u0026hellip;\u0026rdquo; appended. Most effective descriptions are much shorter—aim for 200-400 characters for core information, using the full limit only for complex components requiring extensive guidance.\nConfigure custom limits in .config/cem.yaml with mcp.maxDescriptionLength: 5000 or use the --max-description-length flag.\nWriting Principles Focus descriptions on purpose and context (what the component/attribute/slot is for, not just what it is), usage guidelines (when and how to use it effectively), relationships (how it works with other features), and constraints (what to avoid). The MCP server automatically combines your descriptions with type definitions, valid values, schema descriptions, and cross-component consistency information to create comprehensive AI guidance.\nUse RFC 2119 Keywords The MCP server extracts actionable guidelines by looking for RFC 2119 keywords (MUST/must, SHOULD/should, AVOID/avoid, USE/use) in your descriptions. For example, \u0026ldquo;Must be \u0026rsquo;large\u0026rsquo; for primary mobile actions to meet accessibility requirements\u0026rdquo; creates structured guidance that AI uses for validation and code generation. Descriptions without these keywords provide only type information without behavioral guidance.\nWriting Effective Descriptions Write descriptions that serve both human developers and AI systems by being clear and actionable. Include usage context explaining when and how to use components—for example, \u0026ldquo;A card container for grouping related content. Should include a header slot for titles and supports elevation levels 0-5 for visual hierarchy\u0026rdquo; is better than \u0026ldquo;A card component with slots.\u0026rdquo;\nEmphasize accessibility requirements since they\u0026rsquo;re a core priority. Descriptions like \u0026ldquo;An interactive toggle button that announces state changes to screen readers. Must include aria-pressed attribute and supports keyboard activation with Space or Enter keys\u0026rdquo; help AI generate accessible code.\nCombine TypeScript union types with guideline-rich descriptions for maximum effectiveness—AI extracts type suggestions from the union, usage guidelines from RFC 2119 keywords, accessibility context from your descriptions, and anti-patterns from AVOID statements.\nHow cem mcp Presents Your Content cem mcp provides AI agents with your content in the form of resources. Each resource combines your descriptions with relevant schema information:\nYour Description + Type Information + Schema Context = Rich AI Guidance Example: For an attribute description like \u0026ldquo;Button size affecting accessibility\u0026rdquo;, the cem://element/{tagName}/attributes resource combines this with:\nUnion type values ('small' | 'medium' | 'large') Default value information ('medium') Schema descriptions for size concepts Cross-component consistency patterns Result: AI receives comprehensive guidance like:\nButton size affects touch targets and accessibility. Use \u0026lsquo;small\u0026rsquo; for compact layouts, \u0026lsquo;medium\u0026rsquo; for standard interfaces, \u0026rsquo;large\u0026rsquo; for mobile-first actions. Each size ensures minimum touch target requirements for accessibility compliance.\nWriting for Resource Specialization Since resources focus on specific aspects, tailor your descriptions accordingly:\nFor Element Descriptions (used by element_details) Focus on overall purpose, main use cases, and key relationships:\nAn accessible card container for grouping related content with semantic markup. Use for dashboard widgets, content previews, and information grouping. Supports responsive design and maintains proper heading hierarchy.\nFor Attribute Descriptions (enhanced by cem://element/{tagName}/attributes) Focus on purpose, constraints, and usage context:\n/** * Controls card prominence in visual hierarchy. Use \u0026#39;flat\u0026#39; for embedded content, * \u0026#39;raised\u0026#39; for interactive cards, \u0026#39;floating\u0026#39; for modal-style overlays. */ elevation: \u0026#39;flat\u0026#39; | \u0026#39;raised\u0026#39; | \u0026#39;floating\u0026#39; For Slot Descriptions (used by cem://element/{tagName}/slots) Focus on content types, accessibility, and relationships:\nCard header area for titles and actions. Should contain heading elements (h2-h4) to maintain document structure. Avoid interactive elements that conflict with card-level actions. Announced first by screen readers.\nThe declarative framework ensures that your focused descriptions are automatically enhanced with relevant schema information, type constraints, and cross-component patterns to provide comprehensive AI guidance.\nElement Descriptions Element descriptions should answer what the component is and when to use it. Structure descriptions as: component purpose, accessibility features, usage guidelines, and context information. For example, describe interactive components by their role and keyboard support, layout components by their semantic structure and responsive behavior, and navigation components by their WCAG patterns and focus management.\nAttribute Descriptions Attribute descriptions should explain what the attribute controls and how to use it. Include type information, valid values, impact on behavior, and usage context. Explain default behavior and when to override defaults.\nButton visual style and semantic meaning. Use 'primary' for main actions, 'secondary' for supporting actions, 'danger' for destructive actions, and 'ghost' for subtle actions. Affects color contrast and accessibility announcements. Good: Complete attribute information Button style Poor: Minimal information Slot Descriptions Slot descriptions should explain what content belongs in the slot and how it should be structured. Describe expected content types (heading elements, interactive elements, text), accessibility considerations (screen reader announcements, focus management), and content relationships (how slot content works with other slots).\nCard header content, typically a heading element (h2-h4) or title text. Should establish the card's purpose and maintain proper heading hierarchy. Avoid interactive elements that might conflict with card-level actions. Good: Specific content guidance Header content Poor: Generic description CSS Property Descriptions CSS property descriptions should explain what visual aspect the property controls and how it fits the design system. Link to design system concepts (elevation scales, spacing tokens, color schemes), explain visual and functional impact, and reference design tokens for consistency.\nControls card shadow depth using design system elevation scale. Maps to elevation tokens 0-5 where 0 is flat and 5 is highest prominence. Affects both visual hierarchy and accessibility by indicating interactive priority. Good: Design system integration Card shadow depth Poor: No context or guidance Event Descriptions Event descriptions should explain when the event fires and what data it provides. Describe trigger conditions (user interactions, state changes), event detail contents (data structure, accessibility information), and debouncing or throttling behavior.\nFired when user selects or deselects items, including keyboard and mouse interactions. Event detail contains selectedItems array and previousSelection for accessibility announcements. Debounced to prevent excessive firing during rapid selection changes. Good: Complete event information Fired when selection changes Poor: No detail about triggers or data CSS Parts and States CSS parts descriptions should explain the styling purpose, inheritance behavior, and accessibility requirements for color contrast. For CSS states, describe the behavioral context, when the state is applied, and how to provide visual feedback while maintaining accessibility.\nThe input field element for styling text appearance, borders, and focus states. Inherits form-level styling but can be customized for specific use cases. Maintain sufficient color contrast for accessibility. Good: Clear styling guidance Input field part Poor: No styling guidance or context Testing Your Descriptions Test your descriptions using the cem mcp server by asking AI to generate HTML using your components, requesting attribute suggestions for different contexts, and verifying that generated examples follow your intended usage patterns. If AI generates inappropriate usage, refine your descriptions for clarity and completeness. The key is balancing thoroughness with clarity, always prioritizing the information needed for proper implementation.\nSee Also AI-Friendly Documentation Example - Comprehensive multi-select component demonstrating best practices MCP Integration - Setup instructions for AI assistants Development Workflow - How MCP fits into the dev cycle Generate Command - JSDoc syntax for documenting components ","link":"https://bennypowers.dev/cem/docs/usage/effective-mcp-descriptions/","section":"docs","title":"Effective Writing for AI"},{"body":" TL;DR: CEM\u0026rsquo;s Go implementation is significantly faster than JavaScript-based tools. Generate benchmarks show ~10x speedup over web-component-analyzer. LSP benchmarks demonstrate sub-millisecond response times for autocomplete and validation. Overview CEM provides two types of benchmarks for comprehensive performance analysis:\nGenerate Tool Benchmarks Performance comparison of custom element manifest generation tools.\nNumber of runs per tool: 100 Number of files analyzed per run: 45 Generate tool benchmark results: lower is better (seconds) : 1.45 @lit-labs/cli 1.45 : 0.82 @custom-elements-manifest/analyzer 0.82 : 0.31 cem generate 0.31 @lit-labs/cli Docs 1.45s Avg Time 52.3KB Avg Output Size 100 Runs Warnings Validation Command npx --yes @lit-labs/cli labs gen --manifest --out data/lit Run Breakdown: Time per Run (seconds) 1.42 1.47 1.51 1.55 1.59 1.63 1100Run # Validation Results 📄 Global schema schema-version-old: validation for manifests with schemaVersion \u003c 2.1.0 may not produce accurate results (version: 1.0.0) 📄 benchmark/components/alert-toast.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass AlertToast → method connectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AlertToast → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AlertToast → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass AlertToast → field styles 📄 benchmark/components/avatar-image.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AvatarImage → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass AvatarImage → method #onError implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AvatarImage → static field styles 📄 benchmark/components/button-element.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ButtonElement → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ButtonElement → static field styles 📄 benchmark/components/clipboard-copy.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ClipboardCopy → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ClipboardCopy → static field styles 📄 benchmark/components/color-picker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ColorPicker → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ColorPicker → method #onInput 📄 benchmark/components/complex-component.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexComponent → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ComplexComponent → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ComplexComponent → field styles 📄 benchmark/components/complex-types.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexTypes → method render 📄 benchmark/components/dark-mode-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DarkModeToggle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DarkModeToggle → method #toggle 📄 benchmark/components/dismiss-button.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DismissButton → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DismissButton → method #dismiss implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass DismissButton → static field styles 📄 benchmark/components/emoji-picker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass EmojiPicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass EmojiPicker → static field styles 📄 benchmark/components/expand-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ExpandToggle → static field styles 📄 benchmark/components/expandable-panel.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandablePanel → method render 📄 benchmark/components/field-label.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FieldLabel → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass FieldLabel → static field styles 📄 benchmark/components/file-uploader.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FileUploader → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass FileUploader → method #onChange 📄 benchmark/components/icon-badge.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass IconBadge → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass IconBadge → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass IconBadge → field styles 📄 benchmark/components/image-gallery.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ImageGallery → method render 📄 benchmark/components/inline-edit.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass InlineEdit → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #startEdit private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onInput private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onBlur implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass InlineEdit → static field styles 📄 benchmark/components/keyboard-shortcut.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass KeyboardShortcut → method connectedCallback lifecycle-web-components: lifecycle method should not be documented in public API\nclass KeyboardShortcut → method disconnectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass KeyboardShortcut → method render 📄 benchmark/components/load-spinner.js lifecycle lifecycle-web-components: lifecycle method should not be documented in public API\nclass LoadSpinner → method connectedCallback lifecycle-web-components: lifecycle method should not be documented in public API\nclass LoadSpinner → method disconnectedCallback lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass LoadSpinner → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass LoadSpinner → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass LoadSpinner → field styles 📄 benchmark/components/markdown-viewer.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MarkdownViewer → method render 📄 benchmark/components/message-bubble.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MessageBubble → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass MessageBubble → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass MessageBubble → field styles 📄 benchmark/components/multi-slot.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MultiSlot → method render 📄 benchmark/components/no-decorator.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NoDecoratorElement → method render 📄 benchmark/components/notification-banner.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NotificationBanner → method render 📄 benchmark/components/privacy-test.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass PrivacyTest → method render private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass PrivacyTest → static field styles 📄 benchmark/components/progress-circle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ProgressCircle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ProgressCircle → method #color implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ProgressCircle → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ProgressCircle → field styles 📄 benchmark/components/range-slider.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass RangeSlider → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass RangeSlider → method #onInput 📄 benchmark/components/resize-handle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ResizeHandle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ResizeHandle → static field styles 📄 benchmark/components/search-bar.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SearchBar → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass SearchBar → method #onInput 📄 benchmark/components/section-header.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SectionHeader → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SectionHeader → static field styles 📄 benchmark/components/skeleton-block.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SkeletonBlock → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SkeletonBlock → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass SkeletonBlock → field styles 📄 benchmark/components/split-pane.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SplitPane → method render 📄 benchmark/components/star-rating.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StarRating → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass StarRating → method #setRating 📄 benchmark/components/step-progress.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StepProgress → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass StepProgress → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass StepProgress → field styles 📄 benchmark/components/tab-navigation.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TabNavigation → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass TabNavigation → method #select 📄 benchmark/components/tag-list.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TagList → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TagList → static field styles 📄 benchmark/components/text-ticker.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TextTicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TextTicker → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass TextTicker → field styles 📄 benchmark/components/theme-toggle.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ThemeToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ThemeToggle → static field styles 📄 benchmark/components/toast-stack.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToastStack → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ToastStack → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ToastStack → field styles 📄 benchmark/components/toggle-switch.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToggleSwitch → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ToggleSwitch → method #onToggle 📄 benchmark/components/user-avatar.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserAvatar → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass UserAvatar → static field styles 📄 benchmark/components/user-list.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserList → method render 📄 benchmark/components/visually-hidden.js lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass VisuallyHidden → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass VisuallyHidden → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass VisuallyHidden → field styles @custom-elements-manifest/analyzer Docs 0.82s Avg Time 66.1KB Avg Output Size 100 Runs Warnings Validation Command npx --yes @custom-elements-manifest/analyzer analyze --outdir data/cea --globs benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.79 0.80 0.81 0.82 0.83 0.84 1100Run # Validation Results 📄 Global schema schema-version-old: validation for manifests with schemaVersion \u003c 2.1.0 may not produce accurate results (version: 1.0.0) 📄 benchmark/components/alert-toast.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AlertToast → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AlertToast → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass AlertToast → field styles 📄 benchmark/components/avatar-image.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass AvatarImage → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass AvatarImage → method #onError implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass AvatarImage → static field styles 📄 benchmark/components/button-element.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ButtonElement → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ButtonElement → static field styles 📄 benchmark/components/clipboard-copy.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ClipboardCopy → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ClipboardCopy → static field styles 📄 benchmark/components/color-picker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ColorPicker → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ColorPicker → method #onInput 📄 benchmark/components/complex-component.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexComponent → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ComplexComponent → static field styles 📄 benchmark/components/complex-types.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ComplexTypes → method render 📄 benchmark/components/dark-mode-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DarkModeToggle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DarkModeToggle → method #toggle 📄 benchmark/components/dismiss-button.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass DismissButton → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass DismissButton → method #dismiss implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass DismissButton → static field styles 📄 benchmark/components/emoji-picker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass EmojiPicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass EmojiPicker → static field styles 📄 benchmark/components/expand-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ExpandToggle → static field styles 📄 benchmark/components/expandable-panel.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ExpandablePanel → method render 📄 benchmark/components/field-label.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FieldLabel → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass FieldLabel → static field styles 📄 benchmark/components/file-uploader.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass FileUploader → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass FileUploader → method #onChange 📄 benchmark/components/icon-badge.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass IconBadge → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass IconBadge → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass IconBadge → field styles 📄 benchmark/components/image-gallery.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ImageGallery → method render 📄 benchmark/components/inline-edit.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass InlineEdit → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #startEdit private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onInput private-hash-methods: ECMAScript private method should never be documented in public API\nclass InlineEdit → method #onBlur implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass InlineEdit → static field styles 📄 benchmark/components/keyboard-shortcut.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass KeyboardShortcut → method render 📄 benchmark/components/load-spinner.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass LoadSpinner → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass LoadSpinner → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass LoadSpinner → field styles 📄 benchmark/components/markdown-viewer.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MarkdownViewer → method render 📄 benchmark/components/message-bubble.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MessageBubble → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass MessageBubble → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass MessageBubble → field styles 📄 benchmark/components/multi-slot.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass MultiSlot → method render 📄 benchmark/components/no-decorator.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NoDecoratorElement → method render 📄 benchmark/components/notification-banner.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass NotificationBanner → method render 📄 benchmark/components/privacy-test.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass PrivacyTest → method render private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass PrivacyTest → static field styles 📄 benchmark/components/progress-circle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ProgressCircle → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ProgressCircle → method #color implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ProgressCircle → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ProgressCircle → field styles 📄 benchmark/components/range-slider.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass RangeSlider → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass RangeSlider → method #onInput 📄 benchmark/components/resize-handle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ResizeHandle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ResizeHandle → static field styles 📄 benchmark/components/search-bar.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SearchBar → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass SearchBar → method #onInput 📄 benchmark/components/section-header.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SectionHeader → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SectionHeader → static field styles 📄 benchmark/components/skeleton-block.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SkeletonBlock → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass SkeletonBlock → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass SkeletonBlock → field styles 📄 benchmark/components/split-pane.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass SplitPane → method render 📄 benchmark/components/star-rating.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StarRating → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass StarRating → method #setRating 📄 benchmark/components/step-progress.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass StepProgress → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass StepProgress → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass StepProgress → field styles 📄 benchmark/components/tab-navigation.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TabNavigation → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass TabNavigation → method #select 📄 benchmark/components/tag-list.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TagList → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TagList → static field styles 📄 benchmark/components/text-ticker.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass TextTicker → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass TextTicker → static field styles 📄 benchmark/components/theme-toggle.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ThemeToggle → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ThemeToggle → static field styles 📄 benchmark/components/toast-stack.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToastStack → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass ToastStack → static field styles verbose verbose-defaults: default value is very long, consider simplifying or moving to external configuration\nclass ToastStack → field styles 📄 benchmark/components/toggle-switch.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass ToggleSwitch → method render private private-hash-methods: ECMAScript private method should never be documented in public API\nclass ToggleSwitch → method #onToggle 📄 benchmark/components/user-avatar.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserAvatar → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass UserAvatar → static field styles 📄 benchmark/components/user-list.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass UserList → method render 📄 benchmark/components/visually-hidden.ts lifecycle lifecycle-lit-render: render method in Lit element should not be documented in public API\nclass VisuallyHidden → method render implementation implementation-static-styles: static styles field is implementation detail, should not be documented in public API\nclass VisuallyHidden → static field styles cem generate Docs 0.31s Avg Time 73.6KB Avg Output Size 100 Runs Invalid Validation Command cem generate -o data/cem/custom-elements.json benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.31 0.31 0.31 0.32 0.32 0.32 1100Run # Validation Results 3 Errors schema-additional-properties: property 'attribute' not allowed (/modules/44/declarations/0/members/0) schema-invalid-type: property 'attribute', 'type', 'default' not allowed (/modules/44/declarations/0/members/0) schema-invalid-enum: invalid value, must be one of: method 📄 benchmark/components/privacy-test.js private private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _handleClick private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _updateState private-underscore-methods: underscore-prefixed method should be marked as private or protected, or should not be documented in public API\nclass PrivacyTest → method _privateMethod LSP Server Benchmarks Last benchmark run: 2026-02-09 15:09:23 HTML File Operations Pure LSP protocol timing in .html files. Each benchmark measures the time from LSP request to response completion, using multiple iterations to calculate statistical distributions (mean, median, P95, P99).\nServer Startup CEM: 2.74ms 2.74ms wc-toolkit: 2.77ms 2.77ms Hover Info (290 chars) (505 chars) CEM: 0.43ms 0.43ms wc-toolkit: 1.11ms 1.11ms Autocompletion (122.0 items) (130.3 items) CEM: 1.79ms 1.79ms wc-toolkit: 2.00ms 2.00ms Diagnostics CEM: 2036.50ms 2036.50ms wc-toolkit: 2032.10ms 2032.10ms Find References CEM: 29.87ms 29.87ms wc-toolkit: 1.14ms 1.14ms CEM LSP wc-toolkit ","link":"https://bennypowers.dev/cem/docs/benchmarks/","section":"docs","title":"Benchmarks"},{"body":"The dev server supports three rendering modes that control how your demos are presented: light mode (full development UI), shadow mode (demos in shadow DOM ), and chromeless mode (minimal standalone pages). Choose the mode that fits your workflow—light for interactive development with knobs and live monitoring, shadow for testing CSS encapsulation, or chromeless for automated testing and clean demo sharing.\nAll modes include live reload with smart dependency tracking and support query parameter overrides for quick testing. The rendering mode affects UI presentation and error handling but preserves core functionality like TypeScript transforms, import map injection, and file watching across all modes.\nLight Mode (Default) Light mode provides the full development experience with a PatternFly-based UI that includes sidebar navigation, header with theme toggle and debug info, interactive knobs for attributes and properties, real-time event monitoring, server logs with filtering, manifest browser, and visual live reload status. Error overlays appear for transform failures, making debugging straightforward. This is the standard mode for component development.\nUse cem serve (light mode is the default) or configure it explicitly in .config/cem.yaml:\nserve: demos: rendering: light If the rendering option is omitted or empty, demos default to light mode.\nShadow Mode Shadow mode provides the same full UI as light mode but renders demo content inside a shadow root, letting you test components in encapsulated contexts. Use this when verifying CSS encapsulation, testing :host selectors and shadow piercing, or debugging shadow DOM-specific behaviors.\nStart the server with cem serve --rendering=shadow or configure it in .config/cem.yaml:\nserve: demos: rendering: shadow Chromeless Mode Chromeless mode strips away all dev server UI, serving demos as clean standalone pages ideal for automated testing with Playwright or Puppeteer, embedding in documentation sites, sharing clean demo URLs, or capturing screenshots. Core functionality remains—live reload, file watching, TypeScript/CSS transforms, and import map injection—but errors log to the console instead of showing overlays, and there\u0026rsquo;s no visual chrome, knobs panel, or connection status indicators.\nStart with cem serve --rendering=chromeless or configure it in .config/cem.yaml:\nserve: demos: rendering: chromeless Override per-demo with the ?rendering=chromeless query parameter.\nPlaywright Integration Configure Playwright to use chromeless mode for clean component testing without UI interference:\n// playwright.config.js export default { webServer: { command: \u0026#39;cem serve --rendering=chromeless\u0026#39;, port: 8000, reuseExistingServer: !process.env.CI, }, use: { baseURL: \u0026#39;http://localhost:8000\u0026#39; }, }; // tests/button.spec.js import { test, expect } from \u0026#39;@playwright/test\u0026#39;; test(\u0026#39;button component\u0026#39;, async ({ page }) =\u0026gt; { await page.goto(\u0026#39;/elements/my-button/demo/\u0026#39;); const button = page.locator(\u0026#39;my-button\u0026#39;); await expect(button).toBeVisible(); await button.click(); await expect(button).toHaveAttribute(\u0026#39;aria-pressed\u0026#39;, \u0026#39;true\u0026#39;); }); Query Parameter Override Override the default rendering mode for any demo with the ?rendering= query parameter—useful for testing different contexts without restarting the server, sharing clean demo links, or quick mode comparisons:\nhttp://localhost:8000/elements/button/demo/?rendering=chromeless http://localhost:8000/elements/button/demo/?rendering=shadow http://localhost:8000/elements/button/demo/?rendering=light Valid values are light, shadow, and chromeless. Invalid values are ignored and the configured default is used.\nIframe mode not yet implemented: Specifying iframe mode in the config will cause the server to fail at startup. If iframe is requested via query parameter, the server logs a warning, broadcasts an error overlay, and falls back to shadow mode. Backward Compatibility The legacy ?shadow=true query parameter is still supported and will override to shadow mode:\nhttp://localhost:8000/elements/button/demo/?shadow=true Live Reload and Error Handling All modes use WebSocket -based live reload with smart dependency tracking that only triggers reloads when relevant imported files change. Light and shadow modes show visual connection status with reconnection modals and toasts, while chromeless mode reloads silently with console-only logging.\nError handling adapts to each mode: light and shadow display full-screen overlays for TypeScript/CSS transform errors with visual indicators and detailed logs in the UI, while chromeless logs errors to the browser console with a [CEM] prefix to maintain clean demo presentation even during errors.\nCheck the browser console when using chromeless mode—all dev server messages and errors are logged there. Use Cases by Mode Light DOM (default):\nGeneral component testing with full dev UI Demos that rely on global styles Testing how components integrate with the parent page Interactive development with knobs and event monitoring Shadow DOM:\nTesting encapsulation behavior Verifying CSS custom properties penetrate shadow boundaries Testing ::part() and ::slotted() selectors Ensuring styles don\u0026rsquo;t leak in or out Chromeless:\nAutomated testing with Playwright/Puppeteer Embedding demos in documentation sites Sharing clean demo URLs without dev UI Capturing screenshots for documentation Configuration Examples Default all demos to shadow mode:\nserve: demos: rendering: shadow Then override specific demos back to light mode when needed:\nhttp://localhost:8000/elements/integration-test/demo/?rendering=light Use chromeless for CI testing:\n# .config/cem.ci.yaml serve: demos: rendering: chromeless # In CI pipeline cem serve --config .config/cem.ci.yaml ","link":"https://bennypowers.dev/cem/docs/usage/rendering-modes/","section":"docs","title":"Rendering Modes"},{"body":"Contributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm . Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\nContributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm . TypeScript Version Policy The monorepo uses TypeScript ^5.2.0 across all workspace packages for consistency. This is required because:\nExample projects use Lit 3.0, which requires TypeScript 5.2+ for standard decorator support Maintaining a single TypeScript version across the workspace ensures consistent builds and IDE behavior All new workspace packages should use TypeScript ^5.2.0 in their devDependencies The main CEM tool is written in Go and does not require TypeScript, but TypeScript is used for the VSCode extension and example projects.\nBuilding Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\n","link":"https://bennypowers.dev/cem/docs/contributing/","section":"docs","title":"Contributing"},{"body":"Common issues and solutions when working with CEM.\nManifest is empty Make sure your glob pattern matches your files:\ncem generate --verbose Check the .config/cem.yaml generate.files glob pattern matches your source files.\nComponent not showing in dev server Regenerate manifest: cem generate Check file patterns: Verify generate.files glob in .config/cem.yaml Verify package.json: Ensure customElements field exists Verify manifest content: cem list Check demos: Ensure demo files exist and are discoverable Restart the server: cem serve Demos not discovered Check demo file location matches discovery patterns:\nFiles in demo/ or demos/ directories Files named *.demo.html Or configured in .config/cem.yaml See Working with Demos for details on demo discovery configuration.\nTypeScript errors Ensure you have a tsconfig.json:\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;ES2022\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;ES2022\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;bundler\u0026#34;, \u0026#34;experimentalDecorators\u0026#34;: true } } LSP features not working Check manifest exists: ls custom-elements.json Verify manifest content: cem list Verify LSP is running: Check editor\u0026rsquo;s LSP status Regenerate if stale: cem generate Check LSP logs in your editor Restart editor: Reload window See Using LSP Features for more details.\nDev server won\u0026rsquo;t start Check for port conflicts:\n# Try a different port cem serve --port 3000 Check for syntax errors:\n# Validate your manifest cem validate Import maps not working Check package.json: Ensure dependencies are listed Restart server: cem serve picks up package.json on startup Clear browser cache: Hard reload (Ctrl+Shift+R / Cmd+Shift+R) See Import Maps for configuration details.\nChanges not refreshing Check live reload is enabled (default) Look for errors in browser console Verify source maps for TypeScript Clear browser cache if needed Get Help Documentation - Browse all docs GitHub Issues - Report bugs or request features Examples - See working examples ","link":"https://bennypowers.dev/cem/docs/usage/troubleshooting/","section":"docs","title":"Troubleshooting"},{"body":"","link":"https://bennypowers.dev/cem/categories/","section":"categories","title":"Categories"},{"body":"cem The blazing-fast CLI tool for generating and working with Custom Elements Manifests .\nUse cem to generate , validate , and query custom elements manifests. Develop with the dev server featuring live reload, interactive knobs, and buildless TypeScript. Then, use the built-in LSP and MCP servers to activate powerful, AI-native editor features like hover documentation, autocomplete, and more.\nnpm install --save-dev @pwrs/cem Get Started Read the Docs ","link":"https://bennypowers.dev/cem/","section":"","title":"cem"},{"body":"Getting Started Installation Install CEM and configure LSP, MCP, and editor integrations. Usage Guides Learn the development workflow, explore examples, and use CEM effectively. Reference Technical documentation for commands, configuration, LSP, and MCP protocols. Additional Resources Benchmarks Performance metrics for the analyzer. Contributing Learn how you can help improve `cem`. ","link":"https://bennypowers.dev/cem/docs/","section":"docs","title":"Documentation"},{"body":"Generates custom elements manifest from source code using tree-sitter syntax analysis. Identifies custom elements, properties, attributes, slots, events, CSS parts, and CSS custom properties. See Documenting Components for usage guide.\nSyntax cem generate [files...] [flags] Generate from specific files or globs:\ncem generate \u0026#34;src/**/*.ts\u0026#34; --exclude \u0026#34;src/**/*.test.ts\u0026#34; Generate using configuration file:\ncem generate Best supports LitElements written in idiomatic style with TypeScript decorators. Rudimentary support for extends HTMLElement. See [issue tracker][issues] for feature requests. Arguments Argument Type Description \u0026lt;files or globs\u0026gt; positional (array) Files or glob patterns to include --package, -p string Path to a package directory --output, -o string Write the manifest to this file instead of stdout --watch, -w bool Watch files for changes and regenerate automatically --exclude, -e array Files or glob patterns to exclude --no-default-excludes bool Do not exclude .d.ts files by default --design-tokens string Path or npm specifier for DTCG-format design tokens --design-tokens-prefix string CSS custom property prefix for design tokens --demo-discovery-file-glob string Glob pattern for discovering demo files --demo-discovery-url-pattern string URLPattern with named parameters (:param) for matching demo file paths --demo-discovery-url-template string Go template with functions for generating canonical demo URLs --source-control-root-url string Canonical public source control URL for repository root --project-dir string Deprecated: Use --package instead By default, .d.ts TypeScript declaration files are excluded. Use --no-default-excludes to include all matching files.\nJSDoc Tags Document your custom elements using these JSDoc tags. See Documenting Components for examples.\nClass/Element Level Tags These tags apply to the custom element class:\n@alias — Alternative name for the element @attr / @attribute — Custom element attributes @csspart — CSS shadow parts @cssprop / @cssproperty — Custom CSS properties @cssstate — Custom CSS states @customElement / @element / @tagName — Tag name (when @customElement decorator or customElements.define are not in use) @demo — Demo URL with optional description @deprecated — Marks element as deprecated @event / @fires — Custom events dispatched by the element @example — Code examples with optional captions @slot — Named or default slots @summary — Short summary for documentation Property Level Tags These tags apply to class properties:\n@deprecated — Marks property as deprecated @example — Code examples for property usage @summary — Short summary for the property @type — Property type annotation Method Level Tags These tags apply to class methods:\n@deprecated — Marks method as deprecated @example — Code examples for method usage @param / @parameter — Method parameter documentation @return / @returns — Return value documentation @summary — Short summary for the method CSS Property Level Tags These tags apply to CSS custom properties in stylesheets:\n@deprecated — Marks CSS property as deprecated @example — Code examples for CSS property usage @summary — Short summary for the CSS property @syntax — CSS syntax/type definition Usage Examples Element Level /** * A button component with variants * * @summary Interactive button element * @slot - Button content and icon * @csspart button - The button element * @cssprop --button-bg - Background color * @fires click - Dispatched when button is clicked * @example * ```html * \u0026lt;my-button variant=\u0026#34;primary\u0026#34;\u0026gt;Click me\u0026lt;/my-button\u0026gt; * ``` */ @customElement(\u0026#39;my-button\u0026#39;) class MyButton extends LitElement { } Method Level /** * Calculates the sum of two numbers * * @summary Add two numbers * @param {number} a - First number * @param {number} b - Second number * @returns {number} The sum of a and b * @example * ```typescript * element.add(2, 3); // returns 5 * ``` */ add(a: number, b: number): number { return a + b; } See the generate test fixtures for comprehensive examples.\nConfiguration Configure generation in .config/cem.yaml:\nsourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: files: - \u0026#34;src/**/*.ts\u0026#34; exclude: - \u0026#34;src/**/*.test.ts\u0026#34; output: custom-elements.json designTokens: \u0026#34;npm:@my-ds/tokens/tokens.json\u0026#34; designTokensPrefix: \u0026#34;--my-ds\u0026#34; demoDiscovery: fileGlob: \u0026#34;src/**/demo/*.html\u0026#34; urlPattern: \u0026#34;/src/:tag/demo/:demo.html\u0026#34; urlTemplate: \u0026#34;https://example.com/{{.tag}}/{{.demo}}/\u0026#34; Output Format Generates JSON conforming to the Custom Elements Manifest schema. HTML-sensitive characters are escaped using standard JSON unicode sequences (e.g., \u0026lt; becomes \\u003c) for security.\nSee Also Documenting Components - JSDoc usage guide and examples Development Workflow - When to regenerate the manifest Configuration Reference - All config options ","link":"https://bennypowers.dev/cem/docs/reference/commands/generate/","section":"docs","title":"Generate"},{"body":"The cem list command provides a fast, flexible way to inspect your custom elements manifest.\nWithout any subcommands, cem list prints a table of all declarations in the manifest.\ncem list Flags Flag Description --package, -p Deno-style package specifier (e.g., npm:@scope/package@^1.2.3) or path to a package directory. --format Set the output format. Can be table or tree. Default: table. --deprecated Only show deprecated items. Example:\ncem list --deprecated --format tree cem list --package npm:@vaadin/button@24.3.5 Subcommands tags Lists all custom element tag names in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Class, Module, Summary\nExample:\ncem list tags -c Class -c Module modules Lists all module paths in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Path\nExample:\ncem list modules attributes (aliases: attrs) Lists all attributes for a given custom element.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, DOM Property, Reflects, Summary\nExample:\ncem list attributes -t my-element -c \u0026#34;DOM Property\u0026#34; slots Lists all named and default slots for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list slots -t my-element events Lists all custom events fired by a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Type, Summary\nExample:\ncem list events -t my-element css-properties (aliases: css-props) Lists CSS custom properties for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Syntax, Default, Summary\nExample:\ncem list css-properties -t my-element css-states Lists CSS custom states for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-states -t my-element css-parts Lists CSS shadow parts for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-parts -t my-element methods Lists methods for a tag\u0026rsquo;s class.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Return, Privacy, Summary\nExample:\ncem list methods -t my-element demos Lists all demos for a given custom element.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: URL, Description\nExample:\ncem list demos -t my-element ","link":"https://bennypowers.dev/cem/docs/reference/commands/list/","section":"docs","title":"List"},{"body":"The cem search command lets you search through the custom elements manifest for any element matching the given pattern.\nUsage cem search [pattern] [flags] Description The search command allows you to find any element in your custom elements manifest by searching through names, descriptions, summaries, and labels. This includes:\nCustom element tags Modules and files Attributes Slots CSS properties, parts, and states Events Methods and fields Functions and variables Demos The search pattern is treated as a regular expression by default, allowing for powerful and flexible searches. If the regex is invalid, it automatically falls back to literal string matching.\nAll searches are case-insensitive.\nOptions -f, --format string - Output format: table (default) or tree Examples Basic Search Search for anything containing \u0026ldquo;button\u0026rdquo;:\ncem search button Regular Expression Search Find elements starting with \u0026ldquo;my-\u0026rdquo; and ending with \u0026ldquo;button\u0026rdquo;:\ncem search \u0026#34;^my-.*button$\u0026#34; Find elements containing \u0026ldquo;click\u0026rdquo; OR \u0026ldquo;hover\u0026rdquo;:\ncem search \u0026#34;click|hover\u0026#34; Format Options Display results as a tree:\ncem search button --format tree Display results as a table (default):\ncem search button --format table Specific Content Types Find CSS-related properties:\ncem search \u0026#34;css.*property\u0026#34; Find header-related slots:\ncem search \u0026#34;slot.*header\u0026#34; Find deprecated items:\ncem search deprecated --format tree Output Formats Table Format (Default) The table format shows detailed information organized by sections:\n# \u0026lt;root\u0026gt; # module rh-button/rh-button.js # `\u0026lt;rh-button\u0026gt;` Triggers actions on the page or in the background ## Demos URL | Source -----------------------------------------------|-------- `https://ux.redhat.com/elements/button/demo/` | https://... ## CSS Parts Name -------- `button` Tree Format The tree format shows a hierarchical view of matching elements:\nSearch Results for: button \u0026lt;root\u0026gt; ├─┬ module rh-button/rh-button.js │ └─┬ \u0026lt;rh-button\u0026gt; │ └─┬ Parts │ └── button Regular Expression Features Since patterns are treated as regular expressions, you can use:\n^ - Start of string anchor $ - End of string anchor .* - Match any characters | - OR operator [abc] - Character class \\d, \\w, \\s - Character shortcuts If your regex is invalid, the search automatically falls back to literal string matching.\nGlobal Options The search command also supports all global cem options:\n-p, --package string - Package specifier or path --config string - Config file path -v, --verbose - Verbose output See Also cem list - List specific types of elements from the manifest cem validate - Validate manifest files cem generate - Generate manifest files ","link":"https://bennypowers.dev/cem/docs/reference/commands/search/","section":"docs","title":"Search"},{"body":"","link":"https://bennypowers.dev/cem/tags/","section":"tags","title":"Tags"},{"body":" TL;DR: Run cem validate to check your manifest for errors and get warnings about exposed lifecycle methods, private members in public APIs, and implementation details. Use --disable lifecycle to turn off specific warning categories. The cem validate command validates your custom-elements.json file against its corresponding JSON schema and provides intelligent warnings for potentially inappropriate manifest content.\ncem validate [path/to/custom-elements.json] By default, cem validate will look for a custom-elements.json file in the current directory. You can also provide a path to a different file.\nOptions --verbose, -v: Show detailed information including schema version --disable: Disable specific warning rules or categories (can be used multiple times) --format: Output format, either text (default) or json How it Works The validate command reads the schemaVersion field from your manifest and fetches the corresponding schema from https://unpkg.com/custom-elements-manifest@\u0026lt;version\u0026gt;/schema.json. Schemas are cached locally for performance.\nSchema Validation If the manifest is valid against the JSON schema, the command will exit with a 0 status code and print a success message. If the manifest is invalid, it will print detailed validation errors with contextual information and exit with a non-zero status code.\nIntelligent Warnings Beyond basic schema validation, cem validate analyzes your manifest for patterns that are technically valid but may indicate issues with your API documentation:\nLifecycle Methods Web Components lifecycle: connectedCallback, disconnectedCallback, attributeChangedCallback, adoptedCallback Lit Element lifecycle: firstUpdated, updated, willUpdate, getUpdateComplete, performUpdate, scheduleUpdate, requestUpdate, createRenderRoot Lit Element render method: render (only in Lit elements) Form-associated callbacks: formAssociatedCallback, formDisabledCallback, formResetCallback, formStateRestoreCallback Private Methods and Implementation Details Private methods: Methods starting with _ or # Static implementation fields: styles, shadowRootOptions, formAssociated, observedAttributes Internal utility methods: init, destroy, dispose, cleanup, debug, log Superclass Attribution Built-in types: Warns when built-in types like HTMLElement don\u0026rsquo;t have \u0026quot;module\u0026quot;: \u0026quot;global:\u0026quot; Verbose Content Large CSS defaults: CSS properties with very long default values Output Formats Text Format (Default) The default text format provides human-readable output with colors and formatting.\nJSON Format Use --format json to get machine-readable output suitable for CI/CD pipelines and tooling:\ncem validate --format json custom-elements.json JSON output structure:\n{ \u0026#34;valid\u0026#34;: true, \u0026#34;path\u0026#34;: \u0026#34;custom-elements.json\u0026#34;, \u0026#34;schemaVersion\u0026#34;: \u0026#34;2.1.1\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;schema-required-property\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;my-element.js\u0026#34;, \u0026#34;declaration\u0026#34;: \u0026#34;class MyElement\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;required property \u0026#39;name\u0026#39; is missing\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;/modules/0/declarations/0\u0026#34; } ], \u0026#34;warnings\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;lifecycle-lit-render\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;my-element.js\u0026#34;, \u0026#34;declaration\u0026#34;: \u0026#34;class MyElement\u0026#34;, \u0026#34;member\u0026#34;: \u0026#34;method render\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;render method in Lit element should not be documented in public API\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;lifecycle\u0026#34; } ] } Configuration You can disable specific warning rules using configuration or command-line flags:\nConfiguration File # .cem.yaml warnings: disable: # Disable entire categories - lifecycle - private - implementation # Or disable specific rules - lifecycle-lit-render - implementation-static-styles - private-underscore-methods Command Line # Disable entire categories cem validate --disable lifecycle --disable private # Disable specific rules cem validate --disable lifecycle-lit-render --disable implementation-static-styles # Combine with JSON output cem validate --format json --disable lifecycle The --disable flag can be used multiple times and will be merged with any disabled rules from your configuration file.\nAvailable Warning Categories lifecycle - All lifecycle method warnings private - Private method warnings (underscore and hash prefixed) implementation - Implementation detail warnings (static fields) superclass - Superclass attribution warnings verbose - Verbose content warnings internal - Internal utility method warnings Specific Warning Rule IDs Lifecycle Rules lifecycle-web-components - Web Components lifecycle methods lifecycle-lit-methods - Lit Element lifecycle methods lifecycle-lit-render - Lit Element render method lifecycle-constructor - Constructor method lifecycle-form-callbacks - Form-associated element callbacks Private Method Rules private-underscore-methods - Methods starting with _ private-hash-methods - Methods starting with # Implementation Detail Rules implementation-static-styles - Static styles field implementation-shadow-root-options - shadowRootOptions field implementation-form-associated - formAssociated field implementation-observed-attributes - observedAttributes field Other Rules superclass-builtin-modules - Built-in superclass module attribution verbose-css-defaults - Large CSS property defaults internal-utility-methods - Internal utility methods Schema Validation Error IDs Schema validation errors also include unique IDs for programmatic handling:\nschema-required-property - Missing required property schema-additional-properties - Unexpected additional property schema-invalid-enum - Invalid enum value schema-invalid-kind - Invalid declaration kind schema-invalid-type - Wrong data type schema-invalid-format - Invalid format (e.g., URI, email) schema-invalid-pattern - String doesn\u0026rsquo;t match required pattern schema-value-too-small - Number below minimum schema-value-too-large - Number above maximum schema-string-too-short - String shorter than minLength schema-string-too-long - String longer than maxLength schema-array-too-short - Array shorter than minItems schema-array-too-long - Array longer than maxItems schema-duplicate-items - Array contains duplicate items schema-validation-error - Generic validation error ","link":"https://bennypowers.dev/cem/docs/reference/commands/validate/","section":"docs","title":"Validate"}]