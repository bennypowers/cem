[{"body":"For go binaries:\ngo install bennypowers.dev/cem@latest For NPM projects:\nnpm install --save-dev @pwrs/cem Or clone this repository and build from source:\ngit clone https://github.com/bennypowers/cem.git cd cem make Shell Completion cem supports shell completion for Bash, Zsh, Fish, and PowerShell. The completion scripts provide tab completion for commands, flags, and file paths.\nBash To load completions in your current shell session:\nsource \u0026lt;(cem completion bash) To load completions for every new session, execute once:\nLinux:\ncem completion bash \u0026gt; /etc/bash_completion.d/cem macOS:\ncem completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/cem Zsh To load completions in your current shell session:\nsource \u0026lt;(cem completion zsh) To load completions for every new session, execute once:\ncem completion zsh \u0026gt; \u0026#34;${fpath[1]}/_cem\u0026#34; You will need to start a new shell for this setup to take effect.\nFish To load completions in your current shell session:\ncem completion fish | source To load completions for every new session, execute once:\ncem completion fish \u0026gt; ~/.config/fish/completions/cem.fish PowerShell To load completions in your current shell session:\ncem completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your PowerShell profile.\n","link":"https://bennypowers.dev/cem/docs/installation/","section":"docs","title":"Installation"},{"body":"You can configure cem via a cem.yaml file in your project\u0026rsquo;s .config directory, or by using command-line flags.\nConfiguration File Here is a complete example of a .config/cem.yaml file with all available options explained.\n# The canonical public source control URL for your repository root. # Used for generating source links in the manifest. sourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; # Configuration for the `generate` command. generate: # A list of glob patterns for files to include in the analysis. files: - \u0026#34;src/**/*.ts\u0026#34; # A list of glob patterns for files to exclude from the analysis. exclude: - \u0026#34;src/**/*.test.ts\u0026#34; # The path to write the final custom-elements.json manifest. # If omitted, the manifest is written to standard output. output: \u0026#34;custom-elements.json\u0026#34; # By default, certain files like TypeScript declaration files (`.d.ts`) are excluded. # Set to `true` to include all files matched by the `files` glob. noDefaultExcludes: false # Configuration for integrating Design Tokens. designTokens: # An npm specifier or local path to a DTCG-formatted JSON module. spec: \u0026#34;npm:@my-ds/tokens/tokens.json\u0026#34; # A CSS custom property prefix to apply to the design tokens. prefix: \u0026#34;--my-ds\u0026#34; # Configuration for discovering element demos. demoDiscovery: # A glob pattern to find demo files. fileGlob: \u0026#34;demos/**/*.html\u0026#34; # A Go regexp with named capture groups to extract information from demo file paths. urlPattern: \u0026#34;demos/(?P\u0026lt;tag\u0026gt;[\\\\w-]+)/(?P\u0026lt;demo\u0026gt;[\\\\w-]+).html\u0026#34; # A template to construct the canonical URL for a demo. # Uses `{groupName}` syntax to interpolate captures from `urlPattern`. urlTemplate: \u0026#34;https://example.com/elements/{tag}/{demo}/\u0026#34; Global Flags These flags can be used with any cem command.\nFlag Description --config Path to a custom config file. --package deno-style package specifier, or path to the local package directory. --verbose, -v Enable verbose logging output. --help, -h Show help for a command. Command-Line Flags All configuration options can also be set via command-line flags. Flags will always override any values set in the configuration file.\nFor example, to override the output and exclude options for the generate command:\ncem generate --output my-manifest.json --exclude \u0026#34;src/legacy/**\u0026#34; ","link":"https://bennypowers.dev/cem/docs/configuration/","section":"docs","title":"Configuration"},{"body":"Number of runs per tool: 100 Number of files analyzed per run: 43 Benchmark results: lower is better (seconds) : 1.44 @lit-labs/cli 1.44 : 0.8 @custom-elements-manifest/analyzer 0.80 : 0.21 cem generate 0.21 @lit-labs/cli Docs 1.44s Avg Time 47.3KB Avg Output Size 100 Runs Command npx --yes @lit-labs/cli labs gen --manifest --out data/lit Run Breakdown: Time per Run (seconds) 1.40 1.42 1.44 1.47 1.49 1.51 1100Run # @custom-elements-manifest/analyzer Docs 0.8s Avg Time 59.2KB Avg Output Size 100 Runs Command npx --yes @custom-elements-manifest/analyzer analyze --outdir data/cea --globs benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.77 0.78 0.80 0.81 0.82 0.84 1100Run # cem generate Docs 0.21s Avg Time 46.3KB Avg Output Size 100 Runs Command cem generate -o data/cem/custom-elements.json benchmark/components/*.ts Run Breakdown: Time per Run (seconds) 0.21 0.21 0.22 0.22 0.22 0.23 1100Run # ","link":"https://bennypowers.dev/cem/docs/benchmarks/","section":"docs","title":"Analyzer Benchmarks"},{"body":"The cem command-line tool has several commands to help you generate and query Custom Elements Manifests.\ngenerate: Analyzes your source code to generate a custom-elements.json manifest file. list: Lets you query the manifest to inspect your custom elements API. ","link":"https://bennypowers.dev/cem/docs/commands/","section":"docs","title":"Commands"},{"body":" Contributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm. Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\nContributing to cem Thank you for your interest in contributing to cem! This guide will help you set up your environment for development, building, and testing. Please read carefully and reach out if you have questions.\nGetting Started Fork and clone the repo: git clone https://github.com/bennypowers/cem.git cd cem Install Go (version 1.24 or newer recommended). Install Node.js (version 22 recommended) and npm. Building Native Build (Linux/macOS) To build the project for your local architecture:\nmake build The binary will be output to dist/cem.\nLocal Windows Build Using Podman You can cross-compile Windows binaries from any OS using Podman (or Docker). This will output cem-windows-x64.exe and cem-windows-arm64.exe in your project root.\nInstall Podman for your platform. Run: make windows This will build both Windows x64 and arm64 executables using the parameterized Containerfile. Tip:\nYou can build a specific Windows architecture:\nx64: make windows-x64 arm64: make windows-arm64 Note: These builds are cross-compiled and cannot be run directly on macOS or Linux. Test on a Windows machine or VM if needed.\nWorkspace Package The workspace package provides a consistent interface for working with local and remote packages. It abstracts away the details of whether files are on the local filesystem or need to be fetched from a remote source like the npm registry. This allows the list command to work with both local and remote packages seamlessly.\nTesting This project includes both unit tests and end-to-end (E2E) tests.\nRun unit tests: make test-unit Run E2E tests: make test-e2e Run all tests: make test Code Coverage To view the test coverage report, run:\nmake show-coverage This will open an HTML report in your browser.\nContinuous Integration (CI) All PRs are built and tested via GitHub Actions. The CI will cross-compile for Linux, macOS, and Windows (x64 and arm64), package npm binaries for each platform, and check that npm packaging works. You can see the exact build matrices in .github/workflows/release.yml and .github/workflows/test-build.yml. NPM Packaging The project produces platform-specific npm packages. Platform detection and binary installation are managed by scripts in the npm directory. You can test npm packaging locally with:\nnode scripts/gen-platform-package-jsons.js and validate the package with:\ncd platforms/cem-\u0026lt;platform\u0026gt;-\u0026lt;arch\u0026gt; npm pack --dry-run Multi-Platform Publishing for cem cem uses an esbuild-style optionalDependencies strategy for platform binaries.\nReleasing Tag your release (e.g., v1.2.3) in the main branch. The CI workflow will: Cross-compile and publish each @pwrs/cem-PLATFORM-ARCH package with the correct binary. Publish the main @pwrs/cem package with all subpackages as optionalDependencies. Local Testing Use npm install --ignore-scripts to test installation. The wrapper (bin/cem.js) will find and invoke the platform-specific binary. Requirements Node.js 22+ is required for all packages. All packages are ESM-only (\u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;). Adding a New Platform Add a new entry in scripts/gen-platform-package-jsons.mjs and build logic. Update the main package\u0026rsquo;s optionalDependencies. How It Works The main package (@pwrs/cem) does not ship a binary. On install, npm will only pull in the appropriate platform package. The wrapper script detects your platform and runs the correct binary. Code Formatting \u0026amp; Linting Go: make format make lint Submitting Changes Open a pull request from your fork. Ensure all CI checks pass. Provide a clear description of your changes. Thank you for contributing!\n","link":"https://bennypowers.dev/cem/docs/contributing/","section":"docs","title":"Contributing"},{"body":"","link":"https://bennypowers.dev/cem/categories/","section":"categories","title":"Categories"},{"body":" cem The blazing-fast CLI tool for generating and working with Custom Elements Manifests.\nnpm install --save-dev @pwrs/cem Get Started Read the Docs ","link":"https://bennypowers.dev/cem/","section":"","title":"cem"},{"body":"Welcome to the documentation for cem. Here you\u0026rsquo;ll find everything you need to get started with and master the tool.\nKey Sections Installation: Get cem up and running on your system. Commands: A detailed reference for every command. Benchmarks: Performance metrics for the analyzer. Contributing: Learn how you can help improve cem. ","link":"https://bennypowers.dev/cem/docs/","section":"docs","title":"Documentation"},{"body":" Generates CEM files from source code using syntax analysis powered by go and tree-sitter. Identifies custom elements, classes, variables, functions, and exports. Supports elements written in idiomatic style using Lit and TypeScript, with a @customElement decorator, and @property decorators on class fields. cem generate best supports LitElements written in idiomatic style with TypeScript decorators. There is rudimentary support for extends HTMLElement, but it is not a high priority for development. If you need something more specific open an issue. JSDoc Use JSDoc comments to add metadata to your element classes, similar to other tools. Add a description by separating the name of the item with -\n@attr / @attribute — Custom element attributes @csspart — CSS shadow parts @cssprop / @cssproperty — Custom CSS properties @cssstate — Custom CSS states @demo — Demo URL @deprecated — Marks a feature or member as deprecated @event — Custom events dispatched by the element @slot — Named or default slots @summary — Short summary for documentation See the test-fixtures directory for examples\nHTML Template Analysis for Slots and Parts Automatically detects \u0026lt;slot\u0026gt; elements and part attributes in your element’s render() template. Merges slot and part information found in templates with any provided via JSDoc, ensuring comprehensive documentation in the generated manifest. Deprecation and other metadata for slots and parts can be specified via YAML in HTML comments. Supports documenting slots and parts inline in your template HTML using HTML comments with YAML blocks. YAML comments are not necessary to detect slots and parts, but help in documenting them for your users. Examples \u0026lt;!-- summary: The main slot for content description: | This slot displays user-provided content. Supports multiline **markdown**. deprecated: true --\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;!-- slot: summary: Named slot summary part: summary: Part summary --\u0026gt; \u0026lt;slot name=\u0026#34;info\u0026#34; part=\u0026#34;info-part\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; CSS Custom Properties Supports CSS Custom Properties by scanning css files and css tagged-template-literals\nCustom properties beginning with _ will be ignored (treated as \u0026ldquo;private\u0026rdquo;) e.g. var(--_private) If you provide a Design Tokens Community Group format module (JSON) to cem via the --design-tokens flag, cem will add metadata from your design system to any matching css variables it finds in your elements You can use jsdoc-like comment syntax before each var call to document your variables Example :host { color: /** * custom color for use in this element * @summary color * @deprecated just use the `color` property */ var(--custom-color); border: 1px solid /** Border color of the element */ var(--border-color); } Element Demos cem generate supports documenting your elements\u0026rsquo; demos by linking directly from JSDoc, or by configurable file-system based discovery.\n1. JSDoc @demo Tag Add demos directly to your element class or members with the @demo tag:\n/** * @demo https://example.com/my-element-plain/ * @demo https://example.com/my-element-fancy/ - A fancier demo with description */ @customElement(\u0026#39;my-element\u0026#39;) class MyElement extends LitElement { // ... } Demos defined this way will always appear in your manifest for the element.\n2. Demo Discovery cem can automatically discover demos from your codebase based on your repository structure and configuration.\nDemo Discovery Options Configure demo discovery with the demoDiscovery key in your .config/cem.yaml file\nsourceControlRootUrl: \u0026#34;https://github.com/your/repo/tree/main/\u0026#34; generate: demoDiscovery: fileGlob: \u0026#34;demos/**/*.html\u0026#34; urlPattern: \u0026#34;demos/(?P\u0026lt;tag\u0026gt;[\\w-]+)/(?P\u0026lt;demo\u0026gt;[\\w-]+).html\u0026#34; urlTemplate: \u0026#34;https://example.com/elements/{tag}/{demo}/\u0026#34; Demo discovery options:\nOption Type Description fileGlob string Glob pattern for discovering demo files. sourceControlRootUrl string Canonical public source control URL for your repository root (on the main branch). urlPattern string Pattern for generating demo URLs, e.g. \u0026quot;demos/{tag}.html\u0026quot;. {tag} is replaced by tag name. urlTemplate string (optional) Alternative URL template for demo links. Monorepos If you are planning to use cem in an npm or yarn monorepo, the best way for now is to create a new .config/cem.yaml file for each package you want to generate for, instead of using a top-level config file.\nExample Root package.json:\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;npm run generate --workspaces\u0026#34; }, \u0026#34;workspaces\u0026#34;: [ \u0026#34;./core\u0026#34;, \u0026#34;./elements\u0026#34; ] } core/.config/cem.yaml:\ngenerate: files: - \u0026#39;./**/*.ts\u0026#39; core/package.json\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;cem generate\u0026#34; } } elements/.config/cem.yaml:\ngenerate: files: - \u0026#39;./**/*.ts\u0026#39; elements/package.json\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;generate\u0026#34;: \u0026#34;cem generate\u0026#34; } } Usage Generate a custom elements manifest from your files:\ncem generate \\ \u0026#34;src/**/*.ts\u0026#34; \\ --design-tokens npm:@my-ds/tokens/tokens.json \\ --exclude \u0026#34;src/**/*.test.ts\u0026#34; \\ --output custom-elements.json For npm projects you can use npx @pwrs/cem generate ....\nThe generate command does not support remote packages. To inspect a remote package\u0026rsquo;s manifest, use the cem list command. Command Line Arguments Argument Type Description \u0026lt;files or globs\u0026gt; positional (array) Files or glob patterns to include --package, -p string Path to a package directory. --output, -o string Write the manifest to this file instead of stdout --exclude, -e array Files or glob patterns to exclude --no-default-excludes bool Do not exclude files by default (e.g., .d.ts files will be included unless excluded explicitly) --design-tokens string Path or npm specifier for DTCG-format design tokens --design-tokens-prefix string CSS custom property prefix for design tokens --demo-discovery-file-glob string Glob pattern for discovering demo files --demo-discovery-url-pattern string Go Regexp pattern with named capture groups for generating canonical demo urls --demo-discovery-url-template string URL pattern string using {groupName} syntax to interpolate named captures from the URL pattern --source-control-root-url string Glob pattern for discovering demo files --project-dir string Deprecated: Use --package instead. By default, some files (like .d.ts TypeScript declaration files) are excluded from the manifest. Use --no-default-excludes if you want to include all matching files and manage excludes yourself.\n","link":"https://bennypowers.dev/cem/docs/commands/generate/","section":"docs","title":"Generate"},{"body":"The cem list command provides a fast, flexible way to inspect your custom elements manifest.\nWithout any subcommands, cem list prints a table of all declarations in the manifest.\ncem list Flags Flag Description --package, -p Deno-style package specifier (e.g., npm:@scope/package@^1.2.3) or path to a package directory. --format Set the output format. Can be table or tree. Default: table. --deprecated Only show deprecated items. Example:\ncem list --deprecated --format tree cem list --package npm:@vaadin/button@24.3.5 Subcommands tags Lists all custom element tag names in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Class, Module, Summary\nExample:\ncem list tags -c Class -c Module modules Lists all module paths in the project.\nFlags:\nFlag Description --columns, -c Specify which columns to include. Available Columns: Name, Path\nExample:\ncem list modules attributes (aliases: attrs) Lists all attributes for a given custom element.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, DOM Property, Reflects, Summary\nExample:\ncem list attributes -t my-element -c \u0026#34;DOM Property\u0026#34; slots Lists all named and default slots for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list slots -t my-element events Lists all custom events fired by a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Type, Summary\nExample:\ncem list events -t my-element css-properties (aliases: css-props) Lists CSS custom properties for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Syntax, Default, Summary\nExample:\ncem list css-properties -t my-element css-states Lists CSS custom states for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-states -t my-element css-parts Lists CSS shadow parts for a tag.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Summary\nExample:\ncem list css-parts -t my-element methods Lists methods for a tag\u0026rsquo;s class.\nFlags:\nFlag Description --tag-name, -t (Required) The tag name of the element to inspect. --columns, -c Specify which columns to include. Available Columns: Name, Return, Privacy, Summary\nExample:\ncem list methods -t my-element ","link":"https://bennypowers.dev/cem/docs/commands/list/","section":"docs","title":"List"},{"body":"","link":"https://bennypowers.dev/cem/tags/","section":"tags","title":"Tags"}]