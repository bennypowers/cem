/*
Copyright Â© 2025 Benny Powers <web@bennypowers.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

package importmap

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// testLogger captures warning messages for verification in tests
type testLogger struct {
	warnings *[]string
	infos    *[]string
	errors   *[]string
	debugs   *[]string
}

func (l *testLogger) Warning(msg string, args ...interface{}) {
	if l.warnings != nil {
		*l.warnings = append(*l.warnings, fmt.Sprintf(msg, args...))
	}
}

func (l *testLogger) Info(msg string, args ...interface{}) {
	if l.infos != nil {
		*l.infos = append(*l.infos, fmt.Sprintf(msg, args...))
	}
}

func (l *testLogger) Error(msg string, args ...interface{}) {
	if l.errors != nil {
		*l.errors = append(*l.errors, fmt.Sprintf(msg, args...))
	}
}

func (l *testLogger) Debug(msg string, args ...interface{}) {
	if l.debugs != nil {
		*l.debugs = append(*l.debugs, fmt.Sprintf(msg, args...))
	}
}

// TestImportMap_AutoGeneratedFromPackageJSON verifies basic auto-generation
func TestImportMap_AutoGeneratedFromPackageJSON(t *testing.T) {
	tmpDir := t.TempDir()

	// Create package.json with dependencies
	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create node_modules structure
	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	// Create lit package.json with exports
	litPackageJSON := `{
  "name": "lit",
  "version": "3.0.0",
  "exports": {
    ".": {
      "import": "./index.js"
    }
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// Create actual index.js file
	err = os.WriteFile(filepath.Join(nodeModules, "index.js"), []byte("export const lit = true;"), 0644)
	if err != nil {
		t.Fatalf("Failed to write index.js: %v", err)
	}

	// Generate import map
	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Verify lit is mapped to /node_modules/lit/index.js
	if importMap.Imports["lit"] != "/node_modules/lit/index.js" {
		t.Errorf("Expected lit mapping to /node_modules/lit/index.js, got: %s", importMap.Imports["lit"])
	}
}

// TestImportMap_WorkspacePackages verifies workspace packages are included
func TestImportMap_WorkspacePackages(t *testing.T) {
	tmpDir := t.TempDir()

	// Create root package.json with workspaces
	packageJSON := `{
  "name": "monorepo",
  "workspaces": [
    "packages/*"
  ]
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create workspace package
	workspacePkg := filepath.Join(tmpDir, "packages", "my-component")
	err = os.MkdirAll(workspacePkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create workspace package: %v", err)
	}

	workspacePackageJSON := `{
  "name": "@workspace/my-component",
  "version": "1.0.0",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(workspacePkg, "package.json"), []byte(workspacePackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write workspace package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Verify workspace package is mapped
	if _, exists := importMap.Imports["@workspace/my-component"]; !exists {
		t.Error("Expected @workspace/my-component in import map")
	}
}

// TestImportMap_ExportsFieldResolution verifies exports field is resolved
func TestImportMap_ExportsFieldResolution(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "complex-lib": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "complex-lib")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	// Package with conditional exports (import vs require)
	complexPackageJSON := `{
  "name": "complex-lib",
  "exports": {
    ".": {
      "import": "./esm/index.js",
      "require": "./cjs/index.js"
    }
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(complexPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write complex-lib package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should prioritize "import" condition over "require"
	mapping := importMap.Imports["complex-lib"]
	if !strings.Contains(mapping, "esm/index.js") {
		t.Errorf("Expected mapping to use import condition (esm/index.js), got: %s", mapping)
	}
	if strings.Contains(mapping, "cjs/index.js") {
		t.Errorf("Expected mapping NOT to use require condition (cjs/index.js), got: %s", mapping)
	}
}

// TestImportMap_MainFieldFallback verifies main field is used when exports is missing
func TestImportMap_MainFieldFallback(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "legacy-lib": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "legacy-lib")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	// Package with only main field (no exports)
	legacyPackageJSON := `{
  "name": "legacy-lib",
  "main": "dist/bundle.js"
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(legacyPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write legacy-lib package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should use main field as fallback
	if !strings.Contains(importMap.Imports["legacy-lib"], "dist/bundle.js") {
		t.Errorf("Expected mapping to use main field (dist/bundle.js), got: %s", importMap.Imports["legacy-lib"])
	}
}

// TestImportMap_SubpathPatterns verifies subpath patterns in exports are handled
func TestImportMap_SubpathPatterns(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "utils-lib": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "utils-lib")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	// Package with subpath patterns
	utilsPackageJSON := `{
  "name": "utils-lib",
  "exports": {
    ".": "./index.js",
    "./utils/*": "./esm/utils/*.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(utilsPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write utils-lib package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should handle subpath patterns (mapping them appropriately)
	if _, exists := importMap.Imports["utils-lib"]; !exists {
		t.Error("Expected utils-lib base import in map")
	}

	// Check that subpath pattern mapping exists
	utilsKey := "utils-lib/utils/"
	if mappedPath, exists := importMap.Imports[utilsKey]; !exists {
		t.Fatalf("Expected '%s' wildcard mapping in import map, but key was missing. Available keys: %v", utilsKey, getKeys(importMap.Imports))
	} else if !strings.Contains(mappedPath, "/utils/") {
		t.Errorf("Expected wildcard mapping for '%s' to contain '/utils/', got: %s", utilsKey, mappedPath)
	}
}

// TestImportMap_UserOverrideMerge verifies user override file merges with auto-generated
func TestImportMap_UserOverrideMerge(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create node_modules/lit
	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	litPackageJSON := `{
  "name": "lit",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// Create user override file
	userOverride := `{
  "imports": {
    "react": "https://esm.sh/react@18"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should have both auto-generated lit and user-provided react
	if _, exists := importMap.Imports["lit"]; !exists {
		t.Error("Expected auto-generated lit mapping")
	}
	if importMap.Imports["react"] != "https://esm.sh/react@18" {
		t.Errorf("Expected user override for react, got: %s", importMap.Imports["react"])
	}
}

// TestImportMap_UserOverridesWin verifies user overrides take precedence
func TestImportMap_UserOverridesWin(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	litPackageJSON := `{
  "name": "lit",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// User override for same package (lit)
	userOverride := `{
  "imports": {
    "lit": "https://esm.sh/lit@3"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// User override should win over auto-generated
	if importMap.Imports["lit"] != "https://esm.sh/lit@3" {
		t.Errorf("Expected user override for lit to win, got: %s", importMap.Imports["lit"])
	}
}

// TestImportMap_WorkspaceLocalPaths verifies workspace packages use local paths
func TestImportMap_WorkspaceLocalPaths(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "monorepo",
  "workspaces": [
    "packages/*"
  ]
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	workspacePkg := filepath.Join(tmpDir, "packages", "ui-lib")
	err = os.MkdirAll(workspacePkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create workspace package: %v", err)
	}

	workspacePackageJSON := `{
  "name": "@workspace/ui-lib",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(workspacePkg, "package.json"), []byte(workspacePackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write workspace package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Workspace packages should NOT use /node_modules path
	mapping := importMap.Imports["@workspace/ui-lib"]
	if strings.Contains(mapping, "/node_modules/") {
		t.Errorf("Expected workspace package to NOT use /node_modules path, got: %s", mapping)
	}

	// Should use local path (e.g., /packages/ui-lib/index.js)
	if !strings.Contains(mapping, "/packages/") {
		t.Errorf("Expected workspace package to use /packages/ path, got: %s", mapping)
	}
}

// TestImportMap_WorkspacePriority verifies workspaces override node_modules
func TestImportMap_WorkspacePriority(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "monorepo",
  "workspaces": [
    "packages/*"
  ],
  "dependencies": {
    "@workspace/shared": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create workspace package
	workspacePkg := filepath.Join(tmpDir, "packages", "shared")
	err = os.MkdirAll(workspacePkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create workspace package: %v", err)
	}

	workspacePackageJSON := `{
  "name": "@workspace/shared",
  "version": "1.0.0",
  "exports": {
    ".": "./workspace-index.js"
  }
}`
	err = os.WriteFile(filepath.Join(workspacePkg, "package.json"), []byte(workspacePackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write workspace package.json: %v", err)
	}

	// Also create node_modules version (should be ignored)
	nodeModulesPkg := filepath.Join(tmpDir, "node_modules", "@workspace", "shared")
	err = os.MkdirAll(nodeModulesPkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules package: %v", err)
	}

	nodeModulesPackageJSON := `{
  "name": "@workspace/shared",
  "exports": {
    ".": "./node-modules-index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModulesPkg, "package.json"), []byte(nodeModulesPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write node_modules package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Workspace version should win over node_modules
	mapping := importMap.Imports["@workspace/shared"]
	if strings.Contains(mapping, "node-modules-index.js") {
		t.Errorf("Expected workspace to take priority over node_modules, got: %s", mapping)
	}
	if !strings.Contains(mapping, "workspace-index.js") {
		t.Errorf("Expected workspace package to be used, got: %s", mapping)
	}
}

// TestImportMap_MissingDependencyWarning verifies warnings for missing dependencies
func TestImportMap_MissingDependencyWarning(t *testing.T) {
	tmpDir := t.TempDir()

	// Package.json with dependency but no node_modules
	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "missing-lib": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// No node_modules created - dependency is missing

	warnings := []string{}
	config := &Config{
		Logger: &testLogger{warnings: &warnings},
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should have logged warning about missing dependency
	foundWarning := false
	for _, w := range warnings {
		if strings.Contains(w, "missing-lib") {
			foundWarning = true
			break
		}
	}
	if !foundWarning {
		t.Errorf("Expected warning about missing-lib, got warnings: %v", warnings)
	}
}

// TestImportMap_NoExportsOrMainWarning verifies warnings for packages without exports/main
func TestImportMap_NoExportsOrMainWarning(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "broken-lib": "^1.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "broken-lib")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	// Package with neither exports nor main
	brokenPackageJSON := `{
  "name": "broken-lib",
  "version": "1.0.0"
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(brokenPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write broken-lib package.json: %v", err)
	}

	warnings := []string{}
	config := &Config{
		Logger: &testLogger{warnings: &warnings},
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should have logged warning about missing exports/main
	foundWarning := false
	for _, w := range warnings {
		if strings.Contains(w, "broken-lib") && (strings.Contains(w, "exports") || strings.Contains(w, "main")) {
			foundWarning = true
			break
		}
	}
	if !foundWarning {
		t.Errorf("Expected warning about broken-lib missing exports/main, got warnings: %v", warnings)
	}
}

// TestImportMap_OnlyBareSpecifiers verifies relative/absolute URLs are not processed
func TestImportMap_OnlyBareSpecifiers(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	litPackageJSON := `{
  "name": "lit",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// User override with mixed specifiers
	userOverride := `{
  "imports": {
    "./local.js": "./src/local.js",
    "https://example.com/lib.js": "https://cdn.example.com/lib.js",
    "data:text/javascript,console.log('hi')": "data:text/javascript,console.log('hello')"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should only have bare specifier (lit), not relative/absolute URLs
	// Note: User overrides might still include them, but auto-generation should not
	if _, exists := importMap.Imports["lit"]; !exists {
		t.Error("Expected bare specifier 'lit' in import map")
	}

	// User overrides are preserved as-is (including non-bare specifiers)
	// This test verifies auto-generation only processes bare specifiers
	// The actual filtering happens in auto-generation logic, not user overrides
}

// TestImportMap_ConfigPriorityCLI verifies CLI overrides have highest priority
func TestImportMap_ConfigPriorityCLI(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	litPackageJSON := `{
  "name": "lit",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// User override file
	userOverride := `{
  "imports": {
    "lit": "https://esm.sh/lit@3"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	// CLI overrides should win over both
	config := &Config{
		InputMapPath: overridePath,
		CLIOverrides: map[string]string{
			"lit": "https://cdn.jsdelivr.net/npm/lit@3",
		},
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// CLI override should win
	if importMap.Imports["lit"] != "https://cdn.jsdelivr.net/npm/lit@3" {
		t.Errorf("Expected CLI override to win, got: %s", importMap.Imports["lit"])
	}
}

// TestImportMap_ConfigPriorityFileOverAuto verifies file overrides beat auto-generated
func TestImportMap_ConfigPriorityFileOverAuto(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "lit")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	litPackageJSON := `{
  "name": "lit",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(litPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write lit package.json: %v", err)
	}

	// User override file
	userOverride := `{
  "imports": {
    "lit": "https://esm.sh/lit@3"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// File override should win over auto-generated
	if importMap.Imports["lit"] != "https://esm.sh/lit@3" {
		t.Errorf("Expected file override to win over auto-generated, got: %s", importMap.Imports["lit"])
	}
}

// TestImportMap_DeepMerge verifies deep merge algorithm for nested imports
func TestImportMap_DeepMerge(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "lit": "^3.0.0",
    "react": "^18.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create node_modules
	for _, pkg := range []string{"lit", "react"} {
		nodeModules := filepath.Join(tmpDir, "node_modules", pkg)
		err = os.MkdirAll(nodeModules, 0755)
		if err != nil {
			t.Fatalf("Failed to create node_modules: %v", err)
		}

		pkgJSON := fmt.Sprintf(`{
  "name": "%s",
  "exports": {
    ".": "./index.js"
  }
}`, pkg)
		err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(pkgJSON), 0644)
		if err != nil {
			t.Fatalf("Failed to write %s package.json: %v", pkg, err)
		}
	}

	// User override that only overrides one package
	userOverride := `{
  "imports": {
    "react": "https://esm.sh/react@18"
  }
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(userOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should have both packages
	if len(importMap.Imports) < 2 {
		t.Errorf("Expected at least 2 imports (lit + react), got: %d", len(importMap.Imports))
	}

	// Lit should be auto-generated
	if !strings.Contains(importMap.Imports["lit"], "/node_modules/lit/") {
		t.Errorf("Expected auto-generated lit path, got: %s", importMap.Imports["lit"])
	}

	// React should be overridden
	if importMap.Imports["react"] != "https://esm.sh/react@18" {
		t.Errorf("Expected overridden react path, got: %s", importMap.Imports["react"])
	}
}

// TestImportMap_MultipleWorkspacePatterns verifies multiple workspace patterns
func TestImportMap_MultipleWorkspacePatterns(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "monorepo",
  "workspaces": [
    "packages/*",
    "apps/*"
  ]
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create workspace package
	workspacePkg := filepath.Join(tmpDir, "packages", "ui-lib")
	err = os.MkdirAll(workspacePkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create workspace package: %v", err)
	}

	workspacePackageJSON := `{
  "name": "@workspace/ui-lib",
  "exports": {
    ".": "./index.js"
  }
}`
	err = os.WriteFile(filepath.Join(workspacePkg, "package.json"), []byte(workspacePackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write workspace package.json: %v", err)
	}

	// Create app workspace
	appPkg := filepath.Join(tmpDir, "apps", "demo-app")
	err = os.MkdirAll(appPkg, 0755)
	if err != nil {
		t.Fatalf("Failed to create app workspace: %v", err)
	}

	appPackageJSON := `{
  "name": "@workspace/demo-app",
  "exports": {
    ".": "./main.js"
  }
}`
	err = os.WriteFile(filepath.Join(appPkg, "package.json"), []byte(appPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write app package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should have both workspace packages
	if _, exists := importMap.Imports["@workspace/ui-lib"]; !exists {
		t.Error("Expected @workspace/ui-lib in import map")
	}
	if _, exists := importMap.Imports["@workspace/demo-app"]; !exists {
		t.Error("Expected @workspace/demo-app in import map")
	}
}

// TestImportMap_InvalidOverrideFileHandling verifies graceful handling of invalid JSON
func TestImportMap_InvalidOverrideFileHandling(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project"
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Invalid JSON in override file
	invalidOverride := `{
  "imports": {
    "lit": "https://esm.sh/lit"
  }  // invalid comment
}`
	overridePath := filepath.Join(tmpDir, "import-map.json")
	err = os.WriteFile(overridePath, []byte(invalidOverride), 0644)
	if err != nil {
		t.Fatalf("Failed to write override file: %v", err)
	}

	config := &Config{
		InputMapPath: overridePath,
	}

	_, err = Generate(tmpDir, config)
	// Should return error for invalid JSON
	if err == nil {
		t.Error("Expected error for invalid override file JSON, got nil")
	}
}

// TestImportMap_SerializesToJSON verifies ImportMap serializes correctly
func TestImportMap_SerializesToJSON(t *testing.T) {
	importMap := &ImportMap{
		Imports: map[string]string{
			"lit":   "/node_modules/lit/index.js",
			"react": "https://esm.sh/react@18",
		},
	}

	jsonBytes, err := json.Marshal(importMap)
	if err != nil {
		t.Fatalf("Failed to marshal import map: %v", err)
	}

	jsonStr := string(jsonBytes)
	if !strings.Contains(jsonStr, `"imports"`) {
		t.Error("Expected JSON to contain 'imports' field")
	}
	if !strings.Contains(jsonStr, `"lit"`) {
		t.Error("Expected JSON to contain 'lit' key")
	}
	if !strings.Contains(jsonStr, `/node_modules/lit/index.js`) {
		t.Error("Expected JSON to contain lit value")
	}
}

// TestImportMap_EmptyPackageJSON verifies handling of empty dependencies
func TestImportMap_EmptyPackageJSON(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project"
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should return empty imports map
	if len(importMap.Imports) != 0 {
		t.Errorf("Expected empty imports for project with no dependencies, got: %v", importMap.Imports)
	}
}

// TestImportMap_ScopedPackages verifies scoped package names are handled
func TestImportMap_ScopedPackages(t *testing.T) {
	tmpDir := t.TempDir()

	packageJSON := `{
  "name": "test-project",
  "dependencies": {
    "@lit/reactive-element": "^2.0.0"
  }
}`
	err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	nodeModules := filepath.Join(tmpDir, "node_modules", "@lit", "reactive-element")
	err = os.MkdirAll(nodeModules, 0755)
	if err != nil {
		t.Fatalf("Failed to create node_modules: %v", err)
	}

	scopedPackageJSON := `{
  "name": "@lit/reactive-element",
  "exports": {
    ".": "./reactive-element.js"
  }
}`
	err = os.WriteFile(filepath.Join(nodeModules, "package.json"), []byte(scopedPackageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write scoped package.json: %v", err)
	}

	importMap, err := Generate(tmpDir, nil)
	if err != nil {
		t.Fatalf("GenerateImportMap returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Should handle scoped package name
	if _, exists := importMap.Imports["@lit/reactive-element"]; !exists {
		t.Error("Expected @lit/reactive-element in import map")
	}

	mapping := importMap.Imports["@lit/reactive-element"]
	if !strings.Contains(mapping, "reactive-element.js") {
		t.Errorf("Expected mapping to reactive-element.js, got: %s", mapping)
	}
}

// TestImportMap_MissingPackageJSON_WithOverrides tests that CLI and user overrides
// are still applied when package.json is missing
func TestImportMap_MissingPackageJSON_WithOverrides(t *testing.T) {
	tmpDir := t.TempDir()

	// Create user import map file
	userMapPath := filepath.Join(tmpDir, "importmap.json")
	userMapContent := `{
		"imports": {
			"lit": "/vendor/lit.js",
			"lit/": "/vendor/lit/"
		}
	}`
	err := os.WriteFile(userMapPath, []byte(userMapContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write user import map: %v", err)
	}

	// Test with both user import map and CLI overrides (no package.json)
	config := &Config{
		InputMapPath: userMapPath,
		CLIOverrides: map[string]string{
			"react": "/vendor/react.js",
		},
	}

	importMap, err := Generate(tmpDir, config)
	if err != nil {
		t.Fatalf("Generate returned error: %v", err)
	}

	if importMap == nil {
		t.Fatal("Expected import map, got nil")
	}

	// Verify user import map was applied
	if importMap.Imports["lit"] != "/vendor/lit.js" {
		t.Errorf("Expected lit mapping from user import map, got: %s", importMap.Imports["lit"])
	}
	if importMap.Imports["lit/"] != "/vendor/lit/" {
		t.Errorf("Expected lit/ mapping from user import map, got: %s", importMap.Imports["lit/"])
	}

	// Verify CLI override was applied (highest priority)
	if importMap.Imports["react"] != "/vendor/react.js" {
		t.Errorf("Expected react mapping from CLI override, got: %s", importMap.Imports["react"])
	}
}

// getKeys returns all keys from a map for debugging purposes
func getKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}
