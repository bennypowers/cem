package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// QueryDef holds data about a single query.
type QueryDef struct {
	VarName      string
	QueryName    string
	Captures     []string
	StructFields []string
	QuerySource  string
}

const tmpl = `// Code generated by querygen. DO NOT EDIT.

package queries

import (
	ts "github.com/tree-sitter/go-tree-sitter"
	typescript "github.com/tree-sitter/tree-sitter-jsdoc/bindings/go"
	jsdoc "github.com/tree-sitter/tree-sitter-typescript/bindings/go"
	"sync"
)

var once sync.Once
var compiledQueries map[string]*sitter.Query

func initQueries() {
	compiledQueries = map[string]*sitter.Query{}
	{{range $.Defs}}{
		q, err := sitter.NewQuery([]byte({{printf "%q" .QuerySource}}), {{$.Lang}}.GetLanguage())
		if err != nil {
			panic(fmt.Sprintf("invalid query for {{.VarName}}: %v", err))
		}
		compiledQueries["{{.VarName}}"] = q
	}
	{{end}}
}

func getQuery(name string) *sitter.Query {
	once.Do(initQueries)
	return compiledQueries[name]
}

{{range $.Defs}}
type {{.VarName}}Match struct {
	{{range .StructFields}}{{.}}
	{{end}}
}

func (m *QueryManager) {{.VarName}}(src string) ([]{{.VarName}}Match, error) {
	// match logic placeholder
	// e.g., use getQuery("{{.VarName}}") and return []{{.VarName}}Match
	return nil, nil
}
{{end}}
`

func main() {
	if len(os.Args) < 3 {
		log.Fatal("usage: querygen <queries-dir> <output-file> [lang]")
	}
	queriesDir := os.Args[1]
	outFile := os.Args[2]
	lang := "typescript"
	if len(os.Args) > 3 {
		lang = os.Args[3]
	}
	files, err := os.ReadDir(queriesDir)
	if err != nil {
		log.Fatal(err)
	}
	var defs []QueryDef
	for _, f := range files {
		if !strings.HasSuffix(f.Name(), ".scm") {
			continue
		}
		name := strings.TrimSuffix(f.Name(), ".scm")
		querySrc, err := os.ReadFile(filepath.Join(queriesDir, f.Name()))
		if err != nil {
			log.Fatal(err)
		}
		lines := strings.Split(string(querySrc), "\n")
		captures := []string{}
		for _, ln := range lines {
			if i := strings.Index(ln, "#"); i >= 0 {
				ln = ln[:i]
			}
			ln = strings.TrimSpace(ln)
			if ln == "" {
				continue
			}
			if i := strings.Index(ln, "@"); i >= 0 {
				capName := strings.Trim(ln[i+1:], "\"'() ")
				if capName != "" && !slices.Contains(captures, capName) {
					captures = append(captures, capName)
				}
			}
		}
		fields := []string{}
		for _, capName := range captures {
			fieldName := snakeToCamel(capName)
			fields = append(fields, fmt.Sprintf("%s string\n", fieldName))
		}
		defs = append(defs, QueryDef{
			VarName:      camelCase(name) + "Query",
			QueryName:    name,
			Captures:     captures,
			StructFields: fields,
			QuerySource:  string(querySrc),
		})
	}
	t := template.Must(template.New("code").Parse(tmpl))
	out, err := os.Create(outFile)
	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()
	err = t.Execute(out, struct {
		Lang string
		Defs []QueryDef
	}{
		Lang: lang,
		Defs: defs,
	})
	if err != nil {
		log.Fatal(err)
	}
}

var caser = cases.Title(language.English)

func camelCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-'
	})
	for i, p := range parts {
		parts[i] = caser.String(p)
	}
	return strings.Join(parts, "")
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, ".")
	for i, p := range parts {
		parts[i] = caser.String(p)
	}
	return strings.Join(parts, "")
}

